-- phpMyAdmin SQL Dump
-- version 5.0.4
-- https://www.phpmyadmin.net/
--
-- Servidor: 127.0.0.1
-- Tiempo de generación: 21-12-2020 a las 17:17:26
-- Versión del servidor: 10.4.17-MariaDB
-- Versión de PHP: 8.0.0

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Base de datos: `semillero`
--

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `capitulos`
--

CREATE TABLE `capitulos` (
  `id_capitulo` int(11) NOT NULL,
  `numero_cap` double DEFAULT NULL,
  `nombre_cap` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Volcado de datos para la tabla `capitulos`
--

INSERT INTO `capitulos` (`id_capitulo`, `numero_cap`, `nombre_cap`) VALUES
(1, 1, 'Introducción a las computadoras, a Internet  y a la World Wide Web'),
(2, 2, 'Introducción a la programación en C'),
(3, 3, 'Desarrollo de programas estructurados en C'),
(4, 4, 'Control de programas en C'),
(5, 5, 'Funciones en C'),
(6, 6, 'Arreglos en C'),
(7, 7, 'Apuntadores en C'),
(8, 8, 'Caracteres y cadenas en C\r\n\r\n'),
(9, 1, 'wdww');

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `indices`
--

CREATE TABLE `indices` (
  `id_indices` int(11) NOT NULL,
  `id_capitulo` int(11) DEFAULT NULL,
  `numero_ind` varchar(10) DEFAULT NULL,
  `nombre_ind` varchar(100) DEFAULT NULL,
  `descripcion_ind` longtext DEFAULT NULL,
  `indice_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Volcado de datos para la tabla `indices`
--

INSERT INTO `indices` (`id_indices`, `id_capitulo`, `numero_ind`, `nombre_ind`, `descripcion_ind`, `indice_id`) VALUES
(1, 1, '1.01', 'Introducción', 'La World Wide Web o simplemente WWW o Web es uno de los métodos más\r\nimportantes de comunicación que existe en Internet. Consiste en un sistema de\r\ninformación basado en Hipertexto (texto que contiene enlaces a otras secciones del\r\ndocumento o a otros documentos). La información reside en forma de páginas Web en\r\nordenadores que se denominan servidores Web y que forman los nodos de esta telaraña.\r\nSe denomina páginas Web a documentos que contienen elementos multimedia\r\n(imágenes, texto, audio, vídeo, etc.) además de enlaces de hipertexto.\r\nEntrando en la Web a través de cualquier servidor se puede navegar por toda la\r\nred, gracias a que la mayoría de las páginas Web contienen enlaces a otras páginas Web\r\nque pueden estar localizadas en el mismo servidor o en cualquier otro servidor de\r\nInternet. ', NULL),
(2, 1, '1.02', '¿Qué es una computadora?', 'Una computadora es un sistema digital con tecnología microelectrónica capaz de procesar datos a partir de un grupo de instrucciones denominado programa. La estructura básica de una computadora incluye microprocesador (CPU), memoria y dispositivos de entrada/salida (E/S), junto a los buses que permiten la comunicación entre ellos. La característica principal que la distingue de otros dispositivos similares, como una calculadora no programable, es que puede realizar tareas muy diversas cargando distintos programas en la memoria para que los ejecute el procesador. ', 1),
(3, 1, '1.03', 'Organización de computadoras', ' Se refiere a la forma en que están estructurados y dispuestos los dispositivos que constituyen a los ordenadores o PC, tanto los elementos que están a la vista como los internos y la manera lógica en que interactúan cada uno de sus sistemas funcionales, para que el usuario tenga un acceso fácil y haga uso de los mismos de un modo relativamente sencillo, más allá de lo complejo del funcionamiento de las unidades que lo conforman o configuran.\r\n• Memoria: está dividida en celdas cuyo contenido es variable y son identificadas con un número fijo llamado “dirección de memoria”. La capacidad total de la memoria está dada por la cantidad de celdas disponibles. Las celdas tienen datos e instrucciones (a diferencia de la arquitectura Harvard que tiene una memoria para datos y otra para instrucciones).\r\n • UAL: unidad encargada de realizar operaciones elementales de tipo aritmético (sumas y restas) y lógicas (comparaciones, NOT, XOR, etc.) \r\n• UC: controla y gobierna todas las operaciones (búsqueda, decodificación y ejecución de instrucciones). • Dispositivo de E/S: gestiona la transferencia de información entre los periféricos y la memoria central.\r\n • Bus de datos: sistema digital que transporta datos entre las distintas partes (no la almacena, solo la transmite). \r\n◦ Bus de datos: mueve la información por los componentes del hardware. \r\n◦ Bus de direcciones: ubica los datos en la memoria. ◦ Bus de control: marca el estado de una instrucción. \r\nSistema operativo:\r\n conjunto de programas residentes en memoria cuya función es administrar los recursos del sistema (memoria, CPU, canales y periféricos) para optimizar su utilización. o Núcleo, supervisor o monitor: parte del SO que está siempre en la memoria (en la parte más baja). \r\no El resto del sistema operativo queda en periféricos (discos), y existe un área donde se cargan las partes del SO que se necesitan y no están en memoria', 2),
(4, 1, '1.04', 'Evolución de los sistemas operativos', ' La informática tal y como se le conoce hoy día, surgió a raíz de la II Guerra Mundial, en la década de los 40. En esos años no existía siquiera el concepto de \"Sistema Operativo\" y los programadores interactuaban directamente con el hardware de las computadoras trabajando en lenguaje máquina (esto es, en binario, programando únicamente con 0s y 1s).\r\n\r\nEl concepto de Sistema Operativo surge en la década de los 50. El primer Sistema Operativo de la historia fue creado en 1956 para un ordenador IBM 704, y básicamente lo único que hacía era comenzar la ejecución de un programa cuando el anterior terminaba.\r\n\r\nEn los años 60 se produce una revolución en el campo de los Sistemas Operativos. Aparecen conceptos como sistema multitarea, sistema multiusuario, sistema multiprocesadores y sistema en tiempo real.\r\n\r\nEs en esta década cuando aparece UNIX, la base de la gran mayoría de los Sistemas Operativos que existen hoy en día.\r\nEn los años 70 se produce un boom en cuestión de ordenadores personales, acercando estos al público general de manera impensable hasta entonces. Esto hace que se multiplique el desarrollo, creándose el lenguaje de programación C (diseñado específicamente para reescribir por completo el código UNIX).\r\n\r\nComo consecuencia de este crecimiento exponencial de usuarios, la gran mayoría de ellos sin ningún conocimiento sobre lenguajes de bajo o alto nivel, hizo que en los años 80, la prioridad a la hora de diseñar un sistema operativo fuese la facilidad de uso, surgiendo así las primeras interfaces de usuario.\r\n\r\nEn los 80 nacieron sistemas como MacOS, MS-DOS, Windows.\r\n                                                                                            En la década de los 90 hace su aparición Linux, publicándose la primera versión del núcleo en septiembre de 1991, que posteriormente se uniría al proyecto GNU, un sistema operativo completamente libre, similar a UNIX, al que le faltaba para funcionar un núcleo funcional. Hoy en día la mayoría de la gente conoce por Linux al Sistema Operativo que realmente se llama GNU/Linux', NULL),
(5, 1, '1.05', 'Computación personal, distribuida y cliente-servidor', 'En 1977, Apple Computers popularizó el fenómeno de la computación personal. Al principio era el sueño de todo aficionado. Las computadoras se hicieron lo suficientemente económicas para que la gente las pudiera adquirir para su uso personal o para negocios. En 1981, IBM, el vendedor de computadoras más grande del mundo, introdujo la PC de IBM. Literalmente, de la noche a la mañana, la computación personal se posicionó en las empresas, en la industria y en las instituciones gubernamentales. Estas computadoras eran unidades “independientes” (la gente hacía su trabajo en su propia máquina y transportaba sus discos de un lado a otro para compartir información). Aunque las primeras computadoras personales no eran lo suficientemente poderosas para compartir el tiempo entre muchos usuarios, estas máquinas podían interconectarse entre sí mediante redes, algunas veces mediante líneas telefónicas y otras mediante redes de área local (LANs)dentro de la empresa. Esto derivó en el fenómeno denominado computación distribuida, en el que la computación de la empresa, en vez de llevarse a cabo dentro de un centro de cómputo, se distribuye a través de redes a los sitios en donde se realiza el trabajo de la empresa. Las computadoras personales eran lo suficientemente poderosas para manejar los requerimientos de cómputo de usuarios individuales, y para manejar de manera electrónica las tareas básicas de comunicación que involucraba la transferencia de información entre una computadora y otra.\r\n\r\nLas computadoras personales actuales son tan poderosas como las máquinas de un millón de dólares de hace apenas una década. Las máquinas de escritorio más poderosas (denominadas estaciones de trabajo) proporcionan al usuario enormes capacidades. La información se comparte de manera muy sencilla a través de redes de computadoras, en donde algunas computadoras denominadas servidores de  archivos ofrecen un lugar común de almacenamiento para programas y datos que pueden ser utilizados por computadoras cliente distribuidas a través de la red; de ahí el término de computación cliente-servidor. C, C++ y Java son lenguajes de programación ampliamente utilizados para crear software para sistemas operativos, para redes de computadoras y para aplicaciones distribuidas cliente-servidor. Los sistemas operativos más populares tales como UNIX, Linux, OS X de Mac y Windows proporcionan el tipo de capacidades que explicamos en esta sección. ', NULL),
(6, 1, '1.06', 'Lenguajes máquina, lenguajes ensambladores y lenguajes de alto nivel', 'Los programadores escriben instrucciones en diversos lenguajes de programación, algunos de estos lenguajes los comprende directamente la computadora, mientras que otros requieren pasos intermedios de traducción. En la actualidad se utilizan cientos de lenguajes de computación, los cuales se dividen en tres tipos generales:\r\nLenguajes máquina.\r\nLenguajes ensambladores.\r\nLenguajes de alto nivel.\r\nCualquier computadora puede entender de manera directa sólo su propio lenguaje máquina. El lenguaje máquina es el “lenguaje natural” de una computadora en particular, y está definido por el diseño del hardware de dicha computadora. Por lo general, los lenguajes máquina consisten en cadenas de números [que finalmente se reducen a unos (1) y ceros (0)] que instruyen a las computadoras para realizar sus operaciones más elementales, una por una. Los lenguajes máquina son dependientes de la máquina, es decir, un lenguaje máquina\r\n\r\nen particular puede utilizarse solamente en un tipo de computadora. Los lenguajes máquina son difíciles de comprender para los humanos, como podrá ver en el programa de lenguaje máquina de la siguiente sección, el cual suma el pago de horas extras a un sueldo base y lo almacena en un sueldo bruto:\r\n\r\n+1300042779\r\n+1400593419\r\n+1200274027\r\n\r\nLa programación en lenguaje máquina era demasiado lenta y tediosa para la mayoría de los programadores. En lugar de utilizar las cadenas de números que las computadoras podían entender de manera directa, los programadores comenzaron a utilizar abreviaturas del inglés para representar las operaciones básicas de la computadora. Estas abreviaturas del inglés formaron la base de los lenguajes ensambladores. Los programas traductores llamados ensambladores se desarrollaron para convertir programas en lenguaje ensamblador a lenguaje máquina a la velocidad de la computadora. La siguiente sección muestra un programa en lenguaje ensamblador que también suma el pago por horas extras a un sueldo base y almacena el resultado en un sueldo bruto, pero de manera más clara que su equivalente en lenguaje máquina:\r\n\r\nLOAD SUELDOBASE\r\nADD SUELDOEXTRA\r\nSTORE SUELDOBRUTO\r\n\r\nAunque dicho código es más claro para los humanos, será incomprensible para las computadoras, hasta que los ensambladores lo traduzcan al lenguaje máquina. El uso de las computadoras se incrementó rápidamente con la llegada de los lenguajes ensambladores, pero éstos aún requerían muchas instrucciones para llevar a cabo las tares más sencillas. Para acelerar el proceso de programación, se desarrollaron los leguajes de alto nivel, en los que las instrucciones individuales llevan a cabo tareas importantes. A los programas traductores que convierten programas escritos en lenguajes de alto nivel a lenguaje máquina, se les llama compiladores. Los lenguajes de alto nivel permiten a los programadores escribir instrucciones que se parecen mucho al inglés común, y contienen la notación matemática común. Un programa de nómina escrito en un lenguaje de alto nivel podría contener una instrucción como la siguiente:\r\n\r\nsueldoBruto = sueldoBase + sueldoExtra\r\n\r\nObviamente, los lenguajes de alto nivel son mucho más recomendables, desde el punto de vista del programador, que los lenguajes máquina y ensamblador. C, C++ y Java son los lenguajes de alto nivel más poderosos, y más amplia mente utilizados.\r\n\r\nEl proceso de compilación de un programa escrito en lenguaje de alto nivel a un lenguaje máquina puede tardar un tiempo considerable. Los programas intérpretes se desarrollaron para que pudieran ejecutar programas de alto nivel sin necesidad de compilar dichos programas a lenguaje máquina. Aunque la ejecución de los programas compilados es más rápida que los programas interpretados, los intérpretes son populares en ambientes de desarrollo de programas, en los cuales los programas se recopilan de manera frecuente conforme se adicionan nuevas características y se corrigen los errores. Una vez que se desarrolla un programa, una versión compilada puede ejecutarse de manera más eficiente. ', NULL),
(7, 1, '1.07', 'FORTRAN, COBOL, Pascal y Ada', 'Se han desarrollado cientos de lenguajes de alto nivel, pero sólo algunos han logrado tener gran aceptación. En la década de los cincuenta, IBM Corporation desarrolló FORTRAN(FORmula TRANslator, traductor de formulas) para que se utilizara en aplicaciones científicas y de ingeniería que requerían cálculos matemáticos complejos. Actualmente, FORTRAN se utiliza amplia mente, en especial en aplicaciones de ingeniería. COBOL(COmmon Business Oriented Language, lenguaje común orientado a los negocios) fue desarrollado en 1959 por fabricantes de computadoras, el gobierno y los usuarios de computadoras en la industria. COBOL se utiliza para aplicaciones comerciales que requieren una manipulación precisa y eficiente de grandes cantidades de datos. Una considerable cantidad de software de negocios se encuentra todavía programada en COBOL. Durante la década de los sesenta, muchas de las grandes iniciativas para desarrollo de software encontraron severas dificultades. Los itinerarios de software generalmente se retrasaban, los costos rebasaban en gran medida los presupuestos, y los productos terminados no eran confiables. La gente comenzó a darse cuenta de que el desarrollo de software era una actividad mucho más compleja de lo que habían imaginado. Las actividades de investigación durante esta década dieron como resultado la evolución de la programación estructurada(un método disciplinado para escribir programas más claros, fáciles de corregir, y más fáciles de modificar).\r\n\r\nUno de los resultados más tangibles de esta investigación fue el desarrollo del lenguaje de programación Pascal por el profesor Niklaus Wirth, en 1971. Pascal, cuyo nombre se debe al aniversario de los setecientos años del nacimiento del filósofo y matemático Blaise Pascal, fue diseñado para la enseñanza de la programación estructurada en ambientes académicos, y de inmediato se convirtió en el lenguaje de programación favorito en varias universidades. Des-afortunadamente, el lenguaje carecía de muchas de las características necesarias para poder utilizarlo en aplicaciones comerciales, industriales y gubernamentales, por lo que no ha sido muy aceptado en estos ambientes.\r\n\r\nEl lenguaje de programación Ada fue desarrollado bajo el patrocinio del Departamento de Defensa de los Estados Unidos (DoD) durante la década de los setenta y principios de la década de los ochenta. Cientos de lenguajes se utilizaron para producir los sistemas de software de comando y control masivo del departamento de defensa. El departamento de defensa quería un lenguaje único que pudiera cubrir la mayoría de sus necesidades. El nombre del lenguaje es en honor de Lady Ada Lovelace, hija del poeta Lord Byron. A Lady Lovelace se le atribuye el haber escrito el primer programa para computadoras en el mundo, a principios de 1800 (para la Máquina Analítica, un dispositivo de cómputo creado por Charles Babbage). Una de las características importantes de Ada se conoce como multitareas; esto permite a los programadores especificar que ocurrirán varias tareas en paralelo. Algunos de los lenguajes de alto nivel más populares que hemos explicado (incluyendo C y C++) generalmente permiten al programador escribir programas que realizan solo una actividad a la vez. Java, mediante una técnica denominada subprocesamiento múltiple, permite a los programadores escribir programas con actividades en paralelo. ', NULL),
(8, 1, '1.08', 'Historia de C', 'Un lenguaje de programación que mantiene una fuerte presencia en la industria es, sin duda, C++. Si bien tiene un alto nivel de complejidad, de acuerdo a algunos desarrolladores, así que es un buen momento para conocer su historia y funcionalidades.\r\n\r\nLa historia nos remonta a la figura de Denis Ritchie, quien introdujo por primera vez el lenguaje de programación C en los Laboratorios Bell de AT&T en 1972 y se implementó por primera vez en la computadora DEC PDP-11. Denise Ritchie usó los conceptos de BCPL y B para desarrollar C y agregó la tipificación de datos y algunas otras características poderosas.\r\n\r\nDespués, en 1979, Bjarne Stroustrup, también empleado de Bell AT & T, comenzó a trabajar en el lenguaje C con las clases. Tomó prestadas las características deseables de muchos otros lenguajes como Simula, Ada, ML, CLU y ALGOL 68. Por lo tanto, además de las características del lenguaje C, C ++ también incluía clases, verificación de tipo fuerte, argumento de función predeterminada y herencia básica. Hasta 1983, se llamaba C con clases, y en 1983 se llamaba C ++. Durante 1998, un comité conjunto ANSI-ISO publicó la especificación para los estándares de lenguaje C ++.\r\n\r\nFascinado por el enfoque orientado a objetos Stroustrup pensó en implementar este paradigma en el desarrollo de software, sin embargo, el lenguaje Simula era demasiado lento para el uso práctico. Así que comenzó a trabajar en C con clases, es decir, comenzó a trabajar en un nuevo lenguaje que tendría un paradigma orientado a objetos mezclado con las características del lenguaje de programación C.\r\n\r\nEn 1983, se denominó C ++ e incluía algunas características complementarias, como clases, herencia, alineación, argumentos de funciones predeterminadas, polimorfismo, encapsulación y verificación de tipos fuerte.\r\n\r\nLa primera edición comercial del lenguaje de programación C ++ se lanzó en octubre de 1985.\r\n\r\nA mediados de 2011, C ++ 11, se lanzó un nuevo estándar de C ++. Fue considerablemente influenciado por el proyecto de la biblioteca Boost y muchos de los nuevos módulos se obtuvieron directamente de las bibliotecas correspondientes de Boost. También agregó otras características nuevas que incluyen una biblioteca completa de aleatorización, compatibilidad con expresiones regulares, una nueva biblioteca de tiempo C ++, una biblioteca de subprocesos estándar, compatibilidad atómica, palabras clave automáticas, compatibilidad mejorada para uniones y listas de inicialización de matrices, nuevas plantillas y clases de contenedor. C ++ 14, lanzado en diciembre de 2014, incluyó mejoras más pequeñas y correcciones de errores en C ++ 11 ', NULL),
(9, 1, '1.09', 'La biblioteca estándar de c', 'La biblioteca estándar de C (también conocida como libc) es una recopilación de archivos de cabecera y bibliotecas con rutinas, estandarizadas por un comité de la Organización Internacional para la Estandarización (ISO), que implementan operaciones comunes, tales como las de entrada y salida o el manejo de cadenas. A diferencia de otros lenguajes como COBOL, Fortran, o PL/1, C no incluye palabras clave para estas tareas, por lo que prácticamente todo programa implementado en C se basa en la biblioteca estándar para funcionar.', NULL),
(10, 1, '1.10', 'C++', 'C++ es un C mejorado, desarrollado por Bjarne Stroustrup en los laboratorios Bell. C++ proporciona un conjunto de características que “pulen” al lenguaje C; sin embargo, lo más importante es que proporciona capacidades para una programación orientada a objetos. C++ se ha convertido en el lenguaje dominante en la industria y en las universidades.\r\n\r\nLos objetos son, esencialmente, componentes reutilizables de software que modelan elementos reales. Una revolución se está gestando en la comunidad del software. Escribir software rápida, correcta y económicamente es aún una meta escurridiza, en una época en la que la demanda de nuevo y más poderoso software se encuentra a la alza. Los desarrolladores de software están descubriendo que utilizar una metodología de diseño e implementación modular y orientada a objetos puede hacer más productivos a los grupos de desarrollo de software, que mediante las populares técnicas de programación anteriores.\r\n\r\nMuchas personas piensan que la mejor estrategia educativa actual es dominar C, y posteriormente estudiar C++. Por lo tanto, para el primer curso de programación I, nos enfocaremos solo en C y posteriormente para un segundo curso podemos presentar una explicación mas enfocada a objetos con C++. ', NULL),
(11, 1, '1.11', 'Java', 'Mucha gente cree que el próximo campo importante en el que los microprocesadores tendrán un impacto profundo es en los dispositivos electrónicos inteligentes para uso doméstico. Al aceptar esto, Sun Microsystems patrocinó, en 1991, un proyecto de investigación de la empresa denominado Green. El proyecto desembocó en el desarrollo de un lenguaje basado en C y C++, al cual, James Gosling llamó Oak, debido a un roble que tenía a la vista desde su ventana en las oficinas de Sun. Posteriormente se descubrió que ya existía un lenguaje de programación con el mismo nombre. Cuando un grupo de gente de Sun visitó una cafetería local, sugirieron el nombre Java(una variedad de café), y así se quedó. Sin embargo, el proyecto Green tuvo algunas dificultades. El mercado para los dispositivos electrónicos inteligentes de uso doméstico no se desarrollaba tan rápido como Sun había anticipado. Peor aún, un contrato importante por el que Sun había competido, se le otorgó a otra empresa. De manera que el proyecto corría peligro de ser cancelado. Pero para su buena fortuna, la popularidad de la World Wide Web explotó en 1993, y la gente de Sun se dio cuenta de inmediato del potencial de Java para crear contenido dinámicopara páginas Web. Sun anunció formalmente a Java en una exposición profesional que tuvo lugar en mayo de 1995. De inmediato, Java generó interés dentro de la comunidad de negocios debido a la fenomenal explosión de la World Wide Web. En la actualidad, Java se utiliza para crear páginas Web con contenido dinámico e interactivo, para desarrollar aplicaciones a gran escala, para aumentar la funcionalidad de los servidores Web (las computadoras que proporcionan el contenido que vemos en los navegadores Web), para proporcionar aplicaciones para dispositivos domésticos (como teléfonos celulares, localizadores y asistentes digitales personales), y más.\r\n\r\nEn 1995, estábamos siguiendo el desarrollo de Java. En noviembre de 1995, asistimos a una conferencia sobre Internet que tuvo lugar en Boston. Un representante de Sun Microsystems dio una animada presentación sobre Java. Mientras la plática se llevaba a cabo, se hizo evidente para nosotros que Java tendría un papel importante en el desarrollo de páginas Web interactivas y con multimedia. Sin embargo, de inmediato vimos un potencial mucho mayor para el lenguaje. Vimos a Java como un magnífico lenguaje para enseñar a los estudiantes de primer año de programación los fundamentos de la computación con gráficos, con imágenes, animación, audio, video, con bases de datos, redes, con subprocesamiento múltiple y de colaboración.  ', NULL),
(12, 1, '1.12', 'BASIC, Visual Basic, Visual C++, C# y .NET', 'El lenguaje de programación BASIC (Beginner´s All-Purpose Symbolic Instruction Code) fue desarrollado a mediados de la década de los sesenta por los profesores del Darmouth College John Kemeny y Thomas Kurtz, como un lenguaje para escribir programas sencillos. El propósito principal de BASIC era familiarizar a los principiantes con las técnicas de programación. Visual Basic fue introducido por Microsoft en 1991 para simplificar el proceso de desarrollo de aplicaciones para Windows. Visual Basic .NET, Visual C++ .NET y C# fueron diseñados para la nueva plataforma de programación de Microsoft llamada .NET. Estos tres lenguajes utilizan la poderosa biblioteca de componentes reutilizables de software llamada Framework Class Library (FCL). De manera comparable a Java, la plataforma .NET permite la distribución de aplicaciones basadas en la Web hacia muchos dispositivos (incluso teléfonos celulares) y computadoras de escritorio. El lenguaje de programación C# fue diseñado de manera específica para la plataforma .NET como el lenguaje que permitiría a los programadores migrar con facilidad hacia .NET. C++, Java y C# tienen todos sus raíces en el lenguaje de programación C.', NULL),
(13, 1, '1.13', 'La tendencia clave del software: Tecnología de objetos', 'El software es un “asunto complejo”. Las mejoras a la tecnología de software comenzaron a aparecer con los beneficios de la denominada programación estructurada (y las disciplinas relacionadas como el análisis y diseño de sistemas estructurados) que se realizaba en la década de los setenta. Pero fue hasta que la tecnología de la programación orientada a objetos se hizo popular en la década de los noventa, que los desarrolla-dores de software sintieron que tenían las herramientas necesarias para realizar mayores adelantos en el proceso de desarrollo de software. En realidad, la tecnología de objetos data de mediados de la década de los sesenta. El lenguaje de programación C++, desarrollado en AT&T por Bjarne Stroustrup a principios de la década de los ochenta, se basa en dos lenguajes: C, el cual se desarrolló inicialmente en AT&T a principios de la década de los sesenta para implementar el sistema operativo UNIX, y Simula 67, un lenguaje de programación para simulación desarrollado en Europa y liberado en 1967. C++ absorbió las características de C y adicionó las capacidades de Simula para crear y manipular objetos. Ni C ni C++ se crearon originalmente para que se utilizaran fuera de los laboratorios de investigación de AT&T. Sin embargo, se desarrollaron con rapidez.\r\n\r\n ¿Qué son los objetos y por qué son tan especiales? En realidad, la tecnología de objetos es un esquema de compactación que permite crear unidades útiles de software. Éstas son grandes y altamente enfocadas a ámbitos de aplicación particulares. Existen objetos de fecha, de hora, de cheques, de facturas, de audio, de video, de archivo, de registro y de otros más. De hecho, casi cualquier sustantivo puede representarse razonablemente como un objeto. Vivimos en un mundo de objetos. Sólo mire a su alrededor. Existen automóviles, aviones, gente, animales, edificios, semáforos, elevadores y otras cosas. Antes de la aparición de los lenguajes orientados a objetos, los lenguajes de programación (tales como FORTRAN, Pascal, Basic y C) se basaban en acciones (verbos), en lugar de cosas u objetos (sustantivos). Los programadores, que viven en un mundo de objetos, programan primordialmente mediante el uso de verbos. Este cambio de paradigma complicó la escritura de programas. Ahora, con la disponibilidad de los lenguajes orientados a objetos tales como Java y C++, los programadores siguen viviendo en un mundo orientado a objetos y pueden programar de una manera orientada a objetos. Éste es un proceso más natural de programación, y ha dado como resultado un mayor grado de productividad. \r\n\r\nUn problema fundamental con la programación por procedimientos es que las unidades de programación no reflejan de manera sencilla y efectiva a las entidades del mundo real; así, estas unidades no son particularmente reutilizables. Con gran frecuencia, los programadores deben comenzar “de nuevo” cada nuevo proyecto y escribir código similar “desde cero”. Esto significa un gasto de tiempo y de dinero, ya que la gente tiene que “reinventar la rueda” repetidamente. Mediante a tecnología de objetos, las entidades de software creadas (llamadas clases), si se diseñan apropiadamente, tienden a ser mucho más reutilizables en proyectos futuros. Con las bibliotecas de componentes reutilizables, tales como la MFC (Microsoft Foundation Classes) y las creadas por Rogue Wave y muchas otras empresas desarrolladoras de software, se puede reducir el esfuerzo requerido para implementar ciertas clases de sistemas (comparado con el esfuerzo que se hubiera requerido para reinventar estas capacidades en nuevos proyectos). Algunas empresas indican que la reutilización de software no es, de hecho, el principal beneficio que obtienen de la programación orientada a objetos. Más bien, mencionan que la programación orientada a objetos tiende a producir software que es más comprensible, mejor organizado y fácil de mantener, modificar y corregir. Esto puede ser importante debido a que se estima que el 80% de los costos de software no están asociados con los esfuerzos originales para desarrollar software, sino que están asociados con la continua evolución y mantenimiento de ese software durante su vida útil. Cualesquiera que sean los beneficios que se perciban de la programación orientada a objetos, es claro que ésta será la metodología clave de la programación en las siguientes décadas.', NULL),
(14, 1, '1.14', 'Conceptos básicos de un ambiente típico de programación en C', 'En general un programa en C son muchas funciones de pequeño tamaño, y no pocas funciones de gran tamaño. La comunicación entre las funciones es por los argumentos, valores de retorno y a través de variables externas o globales o mediante el acceso a la memoria en forma directa.\r\nLos argumentos son siempre pasados por valor, es decir, los valores que tienen las variables o constantes usadas como argumentos en el llamado, se copian en sendas variables (argumentos) de la función llamada.\r\n                                                                                            \r\nC es un lenguaje que distingue entre mayúsculas y minúsculas para su escritura. En general, los programas están constituidos por una función de nombre main (que es el punto de entrada al programa) y otras funciones que son invocadas desde esta u otras.\r\nEstructura de un programa “grande”:\r\n• Uso de archivos cabecera (.h): por lo general sólo contienen definiciones de tipos de datos, prototipos de funciones y comandos del preprocesador de C.\r\n• Uso de varios archivos .c: por lo general con un preámbulo consistente de las definiciones de constantes, cabeceras a incluir, definición de tipos de datos, declaración de variables globales y externas (e inicialización), y una o más funciones\r\n• División en directorios: por lo general agrupando los archivos relacionados o bajo  Informática II – Elementos básicos del Lenguaje C – v. 2011 Pág. 2 de 12 cierta lógica\r\n• Uso de make y makefile: para una fácil y consistente compilación\r\n• Uso de macros en make: típicamente usadas para guardar nombres de archivos\r\nfuente, nombres de archivos objeto, opciones del compilador o links a bibliotecas \r\n', NULL),
(15, 1, '1.15', 'Tendencias de hardware', 'La comunidad de programadores se desarrolla junto con el flujo continuo de avances dramáticos en el hardware, el software y las tecnologías de comunicación. En general, cada año la gente espera pagar más por la mayoría de los servicios y productos. Lo contrario ha sido el caso en los campos de las computadoras y las comunicaciones, especialmente con respecto a los costos de mantenimiento de estas tecnologías. Por muchas décadas, y sin expectativas de cambio alguno en un futuro próximo, los costos de hardware han disminuido de manera rápida, si no es que precipitada. Éste es un fenómeno de la tecnología. Cada uno o dos años, las capacidades de las computadoras tienden a duplicarse mientras que los precios de las computadoras siguen cayendo. \r\n\r\nLa disminución en picada de la relación costo/rendimiento de los sistemas de cómputo se debe a la creciente velocidad y capacidad de la memoria en la cual la computadora ejecuta sus programas, al aumento exponencial en la cantidad de memoria secundaria (tal como el almacenamiento en disco) en la que tienen que almacenar los programas y los datos durante largo tiempo, y al continuo incremento en la velocidad de proceso (la velocidad a la cual se ejecutan los programas en las computadoras, es decir, la velocidad a la que hacen su trabajo). En las comunicaciones ha ocurrido el mismo crecimiento, y sus costos también han ido en picada, especialmente en años recientes con la enorme demanda por ancho de banda de comunicaciones, la cual atrae una enorme competencia. \r\n\r\nNo conocemos otros campos en los que la tecnología se mueva tan rápidamente y los costos disminuyan de la misma forma. Cuando en las décadas de los sesenta y setenta hizo explosión el uso de las computadoras, se hablaba de las grandes mejoras en la productividad humana que las computadoras y las comunicaciones traerían consigo. Sin embargo, estas mejoras no se materializaron. Las empresas gastaron grandes sumas de dinero en computadoras, y con certeza las emplearon eficientemente, pero no vieron realizadas sus expectativas en cuanto a la productividad. Fue la invención de la tecnología de microprocesadores en chips y su amplia utilización a finales de la década de los setenta y en la de los ochenta, lo que sentó la base para las mejoras en la productividad actual.\r\n', NULL),
(16, 1, '1.16', 'Historia del internet', 'us inicios surgen a partir de diversas investigaciones referidas al campo de la comunicación; cómo es que nos comunicamos y cuál  es su estructura.\r\n\r\nEn agosto de 1962 J.C.R Licklider,  elaboró una red interconectada para saber si esta podía ofrecer un servicio global desde cualquier base de  datos. A partir de este momento fue nombrado director del área de informática de La Agencia de Proyectos Avanzados de Investigación de Defensa (DARPA) ubicada en EEUU.\r\n\r\nAños después se elaboró el primer escrito referente a la red, el cual fue titulado “La teoría de la Comunicación de paquetes”. En este se explica cómo es posible que la información viaje a través de redes interconectadas. Pero no fue sino hasta 1968, que se logró definir  y estructurar una red mucho más específica, el internet.\r\n\r\nLa primera red de computadores fue creada por Advanced Research Projects Agency Network (ARPANET), dirigida por el departamento “DOD” (EEUU) como medio de comunicación para los diferentes organismos del país. Esta acción despertó el interés de Robert Elliot Kahn, quien junto con Vinton Cert, inventó el protocolo TCP/IP, tecnología usada para transmitir información en Internet. Kahn comenzó a implementar reglas básicas en donde las herramientas debían utilizarse para que el Internet llegara a su destino por medio de la creación de sistemas operativos.\r\n\r\nPara 1992 se fundó la Sociedad del Internet, creada por el Departamento de Defensa de los Estados Unidos, propagándose de tal forma que propició la aparición del primer virus y ordenador personal.\r\n\r\nAños después, en 1995, llegó el  Internet Explorer, oportunidad que dio paso a grandes lanzamientos; páginas de investigación, blogs, programas para descargar música, etc.\r\n', NULL),
(17, 1, '1.17', 'Historia de la World Wide Web', 'World Wide Web, generalmente conocida como la Web, es un sistema de documentos de hipertexto vinculados accesibles por Internet. Usando un programa conocido como navegador Web se pueden ver páginas que pueden contener textos, imágenes, medios continuos como video o música y casi cualquier elementos multimedia de hoy en día.\r\n\r\nUno de los grandes aciertos del sistema fue la conexión entre las páginas a través de hipervínculos. Esto permite hacer un recorrido no lineal entre los documentos, conocido como navegación.\r\n\r\nLa propuesta original de la Web fue redactada en la CERN (European Organization for Nuclear Research) en el año de 1989 por Sir Timothy John Berners-Lee, tomando como idea precursora a un proyecto jamás materializado llamado Memex. Ideado por Vannevar Bush en 1945, consistía en un dispositivo que almacenaría documentos de todo tipo que serían consultado y editados a través de una especie de teclado con palancas.\r\n\r\nEl 12 de Marzo de 1989 es conocido como el nacimiento de Internet, y posiciona Berners-Lee como padre. La propuesta formal de la Web fue presentada oficialmente en la CERN el 12 de Noviembre de 1990 en parte gracias a la colaboración de Robert Cailliau.\r\n\r\nComo miembro de la CERN, fue quien decidió tomar la idea de Berners-Lee y ayudó tanto en la redacción como en la provisión de recursos para concretar el proyecto. A finales de 1990 ya habían construido el primer servidor Web en un sistema Next, y el primer software navegador-editor de páginas.\r\n\r\nSin embargo, no fue hasta abril de 1993 cuando la CERN decidió permitir el uso libre y gratuito de la Web a la comunidad. La aparición del primer navegador Web MOSAIC de la NCSA (National Center for Supercomputer Applications) marcó el comienzo oficial de la Web como un sistema orientado a la comunidad.\r\n', NULL),
(18, 2, '2.01', 'Introduccion', 'C# es un lenguaje orientado a objetos elegante y con seguridad de tipos que permite a los desarrolladores crear muchos tipos de aplicaciones seguras y sólidas que se ejecutan en el ecosistema de .NET.', NULL),
(19, 2, '2.02', 'Un programa sencillo en C: Impresión de una línea de texto', 'C utiliza una notación que puede parecer extraña para quien no es programador. Comencemos considerando un programa sencillo en C. Nuestro primer ejemplo imprime una línea de texto. \r\n\r\ncomienzan con /*y terminan con */, lo que indica que estas dos líneas son un comentario. Los programadores insertan comentarios para documentarlos programas y para mejorar su legibilidad. Los comentarios no provocan que la computadora realice acción alguna durante la ejecución del programa. El compilador de C ignora los comentarios y no genera código objeto en lenguaje máquina. El comentario anterior sólo describe el número de la figura, el nombre del archivo y el propósito del programa.\r\nLos comentarios también ayudan a otras personas a leer y entender un programa, pero demasiados comentarios pueden ocasionar que un programa sea\r\ndifícil de leer.\r\n\r\nLa línea 3\r\n#include <stdio.h>\r\n\r\nes una directiva del preprocesador de C. Las líneas que comienzan con #son procesadas por el preprocesador antes de que el programa se compile. Esta línea en particular indica al preprocesador que incluya en el programa el contenido del encabezado estándar de entrada/salida (stdio.h). Este encabezado contiene información que el compilador utiliza cuando compila las llamadas a las funciones de la biblioteca estándar de entrada/salida, como printf. En el capítulo 5 explicaremos con más detalle el contenido de los encabezados.\r\n\r\nLa línea 6\r\nint main( )\r\n\r\nforma parte de todos los programas en C. Los paréntesis que aparecen después de main indican que main es un bloque de construcción de programas llamado función. Los programas en C contienen una o más funciones, Una de las cuales debe ser main. Todo programa en C comienza su ejecución en la función main.\r\n\r\nLa llave izquierda, \r\n\r\n{, (línea 7), \r\n\r\nDebe iniciar el cuerpo de cada función. Una llave derecha correspondiente (línea 12), debe finalizar cada función. Este par de llaves y la parte del programa entre ellas se conocen como bloque. El bloque es una unidad importante del programa en C.\r\n\r\nLa línea 8\r\nprintf( “Bienvenido a C!\n” );\r\n\r\nindica a la computadora que realice una acción, es decir, que imprima en la pantalla la cadena de caracteres contenida entre las comillas. En algunas ocasiones a una cadena se le llama cadena de caracteres, mensaje o literal. La línea completa [que incluye printf, su argumento entre paréntesis, y el punto y coma(;)] se conoce como instrucción. Toda instrucción debe finalizar con un punto y coma (también conocido como terminador de la instrucción). Cuando la instrucción printf anterior se ejecuta, ésta imprime en la pantalla el mensaje Bienvenido a C! En general, los caracteres se imprimen exactamente como aparecen entre las comillas de la instrucción printf. Observe que los caracteres \nno aparecieron en pantalla. La diagonal invertida () se conoce como carácter de escape. Éste indica que se espera que printf haga algo fuera de lo ordinario. Cuando una diagonal invertida se encuentra dentro de una cadena, el compilador ve el siguiente carácter y lo combina con la diagonal invertida para formar una secuencia de escape. La secuencia de escape \n significa nueva línea. Cuando una nueva línea aparece en la salida de la cadena por medio de printf, esta nueva línea ocasiona que el cursor se posicione al comienzo de la siguiente línea de la pantalla. En la figura 2.2 aparecen algunas secuencias de escape comunes. Las dos últimas secuencias de escape de la figura 2.2 pueden parecer extrañas. \r\nImagen\r\nDebido a que la diagonal invertida tiene un significado especial en una cadena, es decir, que el compilador la reconoce como un carácter de escape, nosotros utilizamos dos diagonales invertidas para colocar una sola diagonal invertida en una cadena.\r\nImprimir comillas también representa un problema, ya que dichas comillas marcan el límite de una cadena; de hecho, estas comillas no se imprimen. Al utilizar la secuencia de escape ” en una cadena para que sea la salida de printf, indicamos que printf debe desplegar unas comillas.\r\n\r\nLa línea 10\r\nreturn 0; /* indica que el programa terminó con éxito */\r\n\r\nse incluye al final de toda función main. La palabra reservada return representa a uno de los diversos medios que utilizaremos para salir de una función. Cuando se utiliza la instrucción return al final de main, como mostramos en este caso, el valor 0 indica que el programa finalizó exitosamente. En el capítulo 5, explicaremos con detalle las funciones, y las razones para incluir esta instrucción serán claras. Por ahora, simplemente incluya esta instrucción en cada programa, o el compilador podría producir un mensaje de advertencia en algunos sistemas. La llave derecha, }, (línea12), indica el final de la función main.\r\n\r\n\r\nResulta importante observar que las funciones de la biblioteca estándar como printf y scanf no forman parte del lenguaje de programación C. Por ejemplo, el compilador no puede encontrar errores de escritura en printf o scanf. Cuando el compilador compila una instrucción printf, éste sólo proporciona espacio en el programa objeto para una “llamada” a la función de biblioteca. Sin embargo, el compilador no sabe en dónde están las funciones de biblioteca; el enlazador sí lo sabe. Cuando se ejecuta el enlazador, éste localiza las funciones de biblioteca e inserta las llamadas apropiadas para dichas funciones en el programa objeto. Ahora el programa objeto está “completo” y listo para ejecutarse. De hecho, al programa enlazado con frecuencia se\r\nle conoce como ejecutable. Si el nombre de la función está mal escrito, es el enlazador quien detectará el error, ya que no será capaz de hacer coincidir el nombre que se encuentra en el programa en C, con el nombre de ninguna función conocida de las bibliotecas. La función printf puede imprimir de diferentes formas el mensaje Bienvenido a C! Por ejemplo, el programa de la figura 2.3 produce la misma salida que el de la figura 2.1. Esto funciona porque cada printf continúa con la impresión a partir de donde la función printf anterior dejó de imprimir. La primera printf (línea 8) imprime  Bienvenido seguido por un espacio, y la segunda printf (línea 9) comienza a imprimir en la misma línea, inmediatamente después del espacio.', NULL),
(20, 2, '2.03', '\r\n2.3 Otro programa sencillo en C: Suma de dos enteros ', 'El programa que a continuación se muestra realiza la lectura de dos números enteros, e imprime la suma.\r\n\r\nSe declaran las variables que serán de tipo entero a b y suma, posteriormente imprime dos líneas de texto solicitando que se introduzcan dos números a y b, luego se atribuye la suma de a y b a la variable suma, finalmente se imprime el resultado de la suma.\r\n\r\nIniciamos declarando las variables como se detalla a continuación.\r\nCodigo fuente:\r\n#include <iostream.h>\r\n#include <conio.h>\r\nmain()\r\n{int a,b,suma;\r\ncout<<\"\n ingrese numero a:\";\r\ncin>>a;\r\ncout<<\"\n ingrese numero b:\";\r\ncin>>b;\r\nsuma=a+b;\r\ncout<<\"\n la suma de \"<<a<<\"+\"<<b<<\" es:\"<<suma;\r\ngetch();\r\nreturn 0;\r\n}', NULL),
(21, 2, '2.04', 'Conceptos de memoria', 'Definición de variable\r\nUna variable es un espacio para guardar información. Entrando más a detalle una variable es una ubicación en la memoria de la computadora en la cual se puede grabar un valor y por la cual se puede recuperar ese valor más tarde.\r\n\r\nLa memoria RAM de la computadora puede ser vista como una serie de pequeñas casillas, cada una de las casillas esta numerada secuencialmente, este número que se le asigna representa su dirección de memoria y su objetivo es identificarla.\r\n\r\nUna variable reserva uno o más casillas en las cuales es posible grabar datos.\r\n\r\nLos nombres de las variables (por ejemplo, myVariable) es una etiqueta en una sola casilla, para que se pueda encontrarla fácilmente sin saber su actual dirección de memoria.\r\n\r\nRAM es la memoria de acceso aleatorio. Una programa cuando es ejecutado o esta corriendo, es grabado temporalmente en la memoria RAM. Todas las variables, son también, creadas en la memoria RAM. Cuando los programadores hablan de memoria, generalmente se están refiriendo a la memoria RAM.\r\n\r\n \r\nTipos de Variables Memoria\r\nLas variables en C pueden ser de varios tipos y serán utilizadas en función del tipo de datos que queramos almacenar en ellas\r\n\r\nLas variables NOMBRE, nombre, Nombre son tres variables totalmente distintas. (Lenguaje Case Sensitive) y el nombre de una variable no puede comenzar por número (pero puede contener varios) ni tener caracteres especiales (se admite el guión bajo).\r\nPor ejemplo: numero1, j10a, num_alumno, serían variables válidas y 1abc, numero?, num/alumnos serían variables inválidas.\r\n\r\nSegún dónde estén declaradas, las variables pueden ser globales (declaradas fuera de todo procedimiento o función) o locales (declaradas dentro de un procedimiento o función). Las primeras serán accesibles desde todo el código fuente y las segundas sólo en la función donde estén definidas.\r\n\r\nPor otra parte, según el tipo de datos a almacenar, las variables serán:\r\n\r\nTIPO	NOMBRE	ALMACENA	 \r\nNumero	INT	Numeros enteros del -32,767 al +32,767	 \r\nNumero	FLOAT	Numeros Decimales	 \r\nNumero	DOUBLE	Numeros enteros hasta el 2,147,483,647	 \r\ncaracter	CHAR	Un caracter	 \r\n.\r\nEl tipo int se utiliza para guardar números enteros, es decir, que no tienen decimales. El rango de valores admitidos varía según la CPU utilizada.', NULL),
(22, 2, '2.05', 'Aritmética en C', 'Definición de variable\r\nUna variable es un espacio para guardar información. Entrando más a detalle una variable es una ubicación en la memoria de la computadora en la cual se puede grabar un valor y por la cual se puede recuperar ese valor más tarde.\r\n\r\nLa memoria RAM de la computadora puede ser vista como una serie de pequeñas casillas, cada una de las casillas esta numerada secuencialmente, este número que se le asigna representa su dirección de memoria y su objetivo es identificarla.\r\n\r\nUna variable reserva uno o más casillas en las cuales es posible grabar datos.\r\n\r\nLos nombres de las variables (por ejemplo, myVariable) es una etiqueta en una sola casilla, para que se pueda encontrarla fácilmente sin saber su actual dirección de memoria.\r\n\r\nRAM es la memoria de acceso aleatorio. Una programa cuando es ejecutado o esta corriendo, es grabado temporalmente en la memoria RAM. Todas las variables, son también, creadas en la memoria RAM. Cuando los programadores hablan de memoria, generalmente se están refiriendo a la memoria RAM.\r\n\r\n \r\nTipos de Variables Memoria\r\nLas variables en C pueden ser de varios tipos y serán utilizadas en función del tipo de datos que queramos almacenar en ellas\r\n\r\nLas variables NOMBRE, nombre, Nombre son tres variables totalmente distintas. (Lenguaje Case Sensitive) y el nombre de una variable no puede comenzar por número (pero puede contener varios) ni tener caracteres especiales (se admite el guión bajo).\r\nPor ejemplo: numero1, j10a, num_alumno, serían variables válidas y 1abc, numero?, num/alumnos serían variables inválidas.\r\n\r\nSegún dónde estén declaradas, las variables pueden ser globales (declaradas fuera de todo procedimiento o función) o locales (declaradas dentro de un procedimiento o función). Las primeras serán accesibles desde todo el código fuente y las segundas sólo en la función donde estén definidas.\r\n\r\nPor otra parte, según el tipo de datos a almacenar, las variables serán:\r\n\r\nTIPO	NOMBRE	ALMACENA	 \r\nNumero	INT	Numeros enteros del -32,767 al +32,767	 \r\nNumero	FLOAT	Numeros Decimales	 \r\nNumero	DOUBLE	Numeros enteros hasta el 2,147,483,647	 \r\ncaracter	CHAR	Un caracter	 \r\n.\r\nEl tipo int se utiliza para guardar números enteros, es decir, que no tienen decimales. El rango de valores admitidos varía según la CPU utilizada.', NULL);
INSERT INTO `indices` (`id_indices`, `id_capitulo`, `numero_ind`, `nombre_ind`, `descripcion_ind`, `indice_id`) VALUES
(23, 2, '2.06', 'Toma de decisiones: Operadores de igualdad y de relación ', 'Los operadores relacionales y de igualdad prueban las relaciones siguientes:\r\nTABLA 1\r\nOperador	Relación probada\r\n<	Primer operando menor que el segundo operando\r\n>	Primer operando mayor que el segundo operando\r\n<=	Primer operando menor o igual que segundo operando\r\n>=	Primer operando mayor o igual que segundo operando\r\n==	Primer operando igual a segundo operando\r\n!=	Primer operando no igual a segundo operando\r\nLos cuatro primeros operadores de la lista anterior tienen mayor prioridad que los operadores de igualdad (== y !=). Vea la información de prioridad en la tabla Prioridad y asociatividad de los operadores de C.\r\nLos operandos pueden tener tipo entero, flotante o puntero. Los tipos de operando pueden ser diferentes. Los operadores relacionales realizan las conversiones aritméticas habituales sobre operandos de tipo entero y flotante. Además, puede usar las siguientes combinaciones de tipos de operando con los operadores relacionales y de igualdad:\r\nAmbos operandos de cualquier operador relacional o de igualdad puede ser punteros al mismo tipo. Para los operadores de igualdad (==) y desigualdad (!=), el resultado de la comparación indica si los dos punteros direccionan la misma ubicación de memoria. Para los otros operadores relacionales ( <, > , <=, and > =), el resultado de la comparación indica la posición relativa de las dos direcciones de memoria de los objetos a los que se señala. Los operadores relacionales comparan solo desplazamientos.\r\nLa comparación de puntero solo se define para partes del mismo objeto. Si los punteros hacen referencia a miembros de una matriz, la comparación es equivalente a la comparación de los subíndices correspondientes. La dirección del primer elemento de la matriz es “menor que” la dirección del último elemento. En el caso de las estructuras, los punteros a miembros de estructura declarados más tarde son “mayores que” los punteros a miembros declarados antes en la estructura. Los punteros a los miembros de la misma unión son iguales.\r\nUn valor de puntero se puede comparar con el valor constante 0 para igualdad (==) o desigualdad (!=). Un puntero a un valor de 0 se denomina un puntero “NULL”; es decir, no señala a una ubicación de memoria válida.\r\nLos operadores de igualdad siguen las mismas reglas que los operadores relacionales, pero permiten posibilidades adicionales: un puntero se puede comparar con una expresión entera constante con valor 0 o con un puntero a void . Si dos punteros son ambos nulos, se consideran iguales. Los operadores de igualdad comparan tanto el segmento como el desplazamiento.', NULL),
(24, 3, '3.01', 'Introducción', 'Algunas veces se rechaza C++ por ser este\r\nun lenguaje demasiado permisivo y\r\nconducente a escribir programas no legibles y\r\ndifíciles de decifrar. Sin embargo, se puede\r\nintentar el uso de ciertas características del\r\nlenguaje con el fin de modelar\r\napropiadamente el diseño de programas.\r\nEsta introducción es un intento por mantener\r\nun control sobre la escritura en código C++.', NULL),
(25, 3, '3.02', 'Algoritmos', 'La solución a cualquier problema de cómputo involucra la ejecución de una serie de acciones en un orden específico. Al procedimientopara resolver un problema en términos de:\r\n\r\n1. Las acciones a ejecutar.\r\n2. El orden en el cual se llevan a cabo dichas acciones. se le llama algoritmo. El siguiente ejemplo demuestra que es importante especificar correctamente el orden en el que se deben ejecutar las acciones. \r\nConsidere el algoritmo “levantarse y arreglarse” que sigue un joven ejecutivo para salir de la cama e ir a su trabajo:\r\n\r\nLevantarse de la cama.\r\nQuitarse la pijama.\r\nBañarse.\r\nVestirse.\r\nDesayunar.\r\nManejar hacia el trabajo.\r\n\r\nEsta rutina hace que el ejecutivo vaya al trabajo bien preparado para tomar decisiones críticas. Sin embargo, suponga que sigue los mismos pasos en un orden ligeramente diferente:\r\n\r\nLevantarse de la cama.\r\nQuitarse la pijama.\r\nVestirse.\r\nBañarse.\r\nDesayunar.\r\nManejar hacia el trabajo.\r\n\r\nEn este caso, nuestro joven ejecutivo llega al trabajo empapado. A la especificación del orden en el cual se ejecutan las instrucciones dentro de un programa de computadora se le llama control del programa. \r\nEn este capítulo y en el siguiente, investigaremos las capacidades de control del programa de C.\r\n.', NULL),
(26, 3, '3.03', 'Pesudocódigos', 'El pseudocódigo es un lenguaje artificial e informal que ayuda a los programadores a desarrollar algoritmos. El pseudocódigo es similar al inglés común; es conveniente y sencillo, aunque no es un lenguaje de programación real. Los programas en pseudocódigo no se ejecutan en las computadoras, sino que sólo ayudan al programador a “resolver” un programa antes de intentar escribirlo en un lenguaje de programación como C. En este capítulo,\r\nproporcionamos muchos ejemplos respecto a la manera efectiva de utilizar el pseudocódigo para desarrollar programas estructurados en C.\r\n\r\nEl pseudocódigo sólo consiste en caracteres, de manera que los programadores pueden introducir los programas en pseudocódigo a la computadora mediante un programa de edición. La computadora puede desplegar o imprimir una copia reciente del pseudocódigo cuando sea necesario. Un programa en pseudocódigo cuidadosamente preparado puede convertirse fácilmente en su correspondiente programa en C. En muchos casos esto\r\nse hace mediante un simple reemplazo de las instrucciones en pseudocódigo por sus equivalentes en C.\r\n\r\nEl pseudocódigo sólo consiste en instrucciones de acción, es decir, aquellas que se ejecutan cuando el programa se convirtió de pseudocódigo a C y se ejecutan en C. Las declaraciones no son instrucciones ejecutables. Son mensajes para el compilador. Por ejemplo, la definición\r\n\r\nint  i;\r\n\r\nsimplemente le indica al compilador el tipo de la variable i,e instruye al compilador para que reserve el espacio en memoria para la variable. Sin embargo, esta definición no provoca la ejecución de acción alguna (tal como una entrada, salida, o cálculo) cuando se ejecuta el programa. Algunos programadores eligen mostrar cada variable y mencionar de manera breve el propósito de cada una al principio del pseudocódigo del programa. De nuevo, el pseudocódigo es una ayuda para el desarrollo de programas.\r\n', NULL),
(27, 3, '3.04', 'Estructuras de control', 'Por lo general, las instrucciones dentro de un programa se ejecutan una a una en el orden en que están escritas.\r\nA esto se le llama ejecución secuencial. Varias instrucciones de C, que explicaremos más adelante, permiten al programador especificar que la siguiente instrucción a ejecutarse debe ser otra y no la siguiente en la secuencia. A esto se le llama transferencia de control. Durante la década de los sesentas, se hizo claro que el uso indiscriminado de transferencias de control era el origen de un gran número de dificultades que experimentaban los grupos de desarrollo de software. El dedo de la culpa apunto hacia la instrucción goto,que permite al programador especificar una transferencia de control a un amplio margen de destinos posibles dentro de un programa. La idea de la programación estructurada se convirtió casi en un sinónimo de la “eliminación del goto”. Las investigaciones de Bohm y Jacopini demostraron que los programas se pueden escribir sin instrucción goto alguna. El reto para los programadores de la época era modificar sus estilos hacia una “programación con menos instrucciones goto”. No fue sino hasta la década de los setenta que los profesionales de la programación  comenzaron a tomar en serio a la programación estructurada. Los resultados fueron impresionantes, los\r\ngrupos de desarrollo de software reportaron una reducción en los tiempos de desarrollo, la entrega más oportuna de los sistemas y el apego más frecuente al presupuesto de los proyectos de software. La clave de este éxito fue simplemente que los programas producidos mediante técnicas estructuradas eran más claros, más fáciles de mantener y depurar, y tenían más probabilidades de estar libres de errores desde el principio.\r\nEl trabajo de Bohm y Jacopini demostró que todos los programas se podían escribir en términos de sólo tres estructuras de control,a saber, la estructura secuencial,la estructura de selección,y la estructura de repetición. La estructura de secuencia se encuentra esencialmente dentro de C. A menos que se le indique lo contrario, la computadora ejecuta de manera automática las instrucciones en C, una a una, en el orden en que están escritas. El segmento de diagrama de flujode la figura 3.1 muestra la estructura secuencial de C.\r\n\r\n\r\nUn diagrama de flujo es una representación gráfica de un algoritmo o de una porción de un algoritmo. Los diagramas de flujo se dibujan mediante símbolos de propósito especial tales como rectángulos, rombos, óvalos, y pequeños círculos; estos símbolos se conectan mediante flechas llamadas líneas de flujo. \r\n\r\nComo el pseudocódigo, los diagramas de flujo son útiles para desarrollar y representar algoritmos, aunque la mayoría de los programadores prefieren el pseudocódigo. \r\n', NULL),
(29, 3, '3.05', 'La estructura de selección if', 'La  sentencia if se le conoce como estructura de selección simple y su función es realizar o no una determinada acción o sentencia, basándose en el resultado de la evaluación de una expresión (verdadero o falso), en caso de ser verdadero se ejecuta la sentencia.\r\n                                                                                            \r\n                                                                                            Por ejemplo si dada la edad de una persona quiero dar un mensaje de que es o no mayor de edad, suponiendo que una persona mayor de edad tiene por lo menos 21 años, el procedimiento será el siguiente.\r\n\r\n#include <iostream>\r\nusing namespace std;\r\nint main()\r\n\r\n{\r\nint edad;\r\ncout<<\"¿Qué edad tienes? \";\r\ncin>>edad;\r\nif ( edad > 20 )\r\n    cout<<\"Eres mayor de edad\" ;\r\n}\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\ncout<<\"¿Qué edad tienes? \n\";\r\ncin>>edad;\r\nif ( edad > 20 )\r\n   { cout<<\"Eres mayor de edad\";\r\n      cout<<\"Te estas volviendo viejo \";\r\n   }\r\n}', NULL),
(30, 3, '3.06', 'La estructura de selección if...else', 'La  estructura if / else lo que hace es ejecutar una acción si el resultado de la evaluación de la expresión es verdadera y otra acción si el resultado de la  evaluación es falsa.\r\n\r\nLa diferencia con utilizar sólo la estructura if es que si la expresión evaluada es verdadera sólo en ese caso se ejecuta una acción de otro modo se pasa de largo. En cambio en la estructura if / else si la expresión es falsa entonces se ejecuta otra acción.\r\n\r\nconds\r\n\r\nFig. 5.4\r\n\r\nEn síntesis lo que hace esta estructura es realizar una acción si la expresión es verdadera y otra si es falsa.\r\nAquí tenemos un ejemplo para ilustrar la estructura if / else.\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\nif ( edad > 20 )\r\n    cout<<\"Eres mayor de edad\" ;\r\nelse\r\n    cout<<\"No eres mayor de edad\";\r\n}', NULL),
(31, 3, '3.07', 'La instrucción de repetición while', 'La instrucción while es una de las alternativas para la repetición de procesos en programación. Como veremos, guarda cierta similitud con la instrucción for, hasta el punto de que en algunas ocasiones podrá optarse por el uso de una u otra de forma indistinta. While es una palabra clave en C que admite varios usos.\r\n\r\nlogo lenguaje programacion C\r\n \r\n\r\nLa sintaxis a emplear con C es la siguiente:\r\n\r\nwhile (condición) {\r\n\r\nInstrucción 1;\r\n\r\nInstrucción 2;\r\n\r\n.\r\n\r\n.\r\n\r\n.\r\n\r\nInstrucción n;\r\n\r\n}\r\n\r\n \r\n\r\n \r\n\r\nLas instrucciones while son anidables dentro de sí mismas o dentro de otras estructuras. Es importante verificar que los bucles diseñados con esta instrucción dispongan de una condición de salida válida.\r\n\r\nCon este código se nos muestra en pantalla 3 veces hola, gracias a que se ha invertido el sentido del bucle:\r\n\r\n#include <stdio.h> //Ejemplo aprenderaprogramar.com\r\n\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\r\n    int i=0; //Declaración de variable\r\n\r\n    while (i<3) {\r\n\r\n        puts(\"hola\n\");\r\n\r\n        i=i+1;\r\n\r\n    }\r\n\r\n    return 0; /*Fin del programa //return 0 */\r\n\r\n}', NULL),
(32, 3, '3.08', 'Formulación de algoritmos: Ejemplo práctico 1 (repetición controlada por contador)\r\n', 'La repetición controlada por contador requiere:\r\nEl nombre de una variable de control (o contador del ciclo).\r\nEl valor inicial de la variable de control.\r\nEl incremento (o decremento) con el cual, cada vez que se termine un ciclo, la variable de control será modificada.\r\nLa condición que compruebe la existencia del valor final de la variable de control (es decir, si se debe o no seguir con el ciclo).\r\nConsidere el siguiente programa sencillo, que imprime los números de 1 a 7. \r\n\r\n\r\n/*****************************************************************/\r\n/*                                                               */\r\n/*   CASIO fx-9860G SDK Library                                  */\r\n/*                                                               */\r\n/*   File name : contador.c                                 */\r\n/*                                                               */\r\n/*   Copyright (c) 2006 CASIO COMPUTER CO., LTD.                 */\r\n/*                                                               */\r\n/*****************************************************************/\r\n#include \"fxlib.h\"\r\n#include \"stdio.h\"\r\n\r\n//****************************************************************************\r\n//  AddIn_main (Sample program main function)\r\n//\r\n//  param   :   isAppli   : 1 = This application is launched by MAIN MENU.\r\n//                        : 0 = This application is launched by a strip in eACT application.\r\n//\r\n//              OptionNum : Strip number (0~3)\r\n//                         (This parameter is only used when isAppli parameter is 0.)\r\n//\r\n//  retval  :   1 = No error / 0 = Error\r\n//\r\n//****************************************************************************\r\n\r\n/* Repetición controlada por contador */\r\nint AddIn_main(int isAppli, unsigned short OptionNum)\r\n{\r\n    unsigned int key, contador = 1;                 /* inicialización*/ \r\n    char scontador[17];\r\n\r\n    Bdisp_AllClr_DDVRAM();\r\n\r\n    while (contador <= 7){                             /* Condición de repetición*/\r\n        sprintf(scontador, \"%d\", contador);\r\n        locate(1, contador); \r\n        Print((unsigned char*) scontador);\r\n        ++contador;                                         /*incremento*/\r\n    }\r\n    \r\n    while(1){\r\n        GetKey(&key);\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\n//****************************************************************************\r\n//**************                                              ****************\r\n//**************                 Notice!                      ****************\r\n//**************                                              ****************\r\n//**************  Please do not change the following source.  ****************\r\n//**************                                              ****************\r\n//****************************************************************************\r\n\r\n\r\n#pragma section _BR_Size\r\nunsigned long BR_Size;\r\n#pragma section\r\n\r\n\r\n#pragma section _TOP\r\n\r\n//****************************************************************************\r\n//  InitializeSystem\r\n//\r\n//  param   :   isAppli   : 1 = Application / 0 = eActivity\r\n//              OptionNum : Option Number (only eActivity)\r\n//\r\n//  retval  :   1 = No error / 0 = Error\r\n//\r\n//****************************************************************************\r\nint InitializeSystem(int isAppli, unsigned short OptionNum)\r\n{\r\n    return INIT_ADDIN_APPLICATION(isAppli, OptionNum);\r\n}', NULL),
(33, 3, '3.09', ' Formulación de algoritmos mediante mejoramiento arriba-abajo, paso a paso: Ejemplo práctico 2 (repe', 'La repeticion controlada por contador se denomina a veces repetici´on definida porque con anticipaci´on se sabe con exactitud cuantas veces se ejecutara el\r\nciclo. La repetici´on controlada por centinela a veces se denomina repetici´on indefinida porque no se sabe con anticipacion cuantas veces se ejecutar´a el ciclo.\r\n                                                                                            \r\nEl esquema del ciclo con centinela es el siguiente:\r\n\r\nPedir datos.\r\nMientras el dato pedido no coincida con el centinela:\r\nRealizar cálculos.\r\nPedir datos.\r\nEn nuestro caso, pedir datos corresponde a lo siguiente:\r\n\r\nPedir número.\r\nEl programa resultante es el siguiente:\r\n\r\ndef pcn_loop2():\r\n    x=input(\"Ingrese un numero (\'*\' para terminar): \")\r\n\r\n    while x <>\"*\":\r\n        if x > 0:\r\n            print \"Numero positivo\"\r\n        elif x == 0:\r\n            print \"Igual a 0\"\r\n        else:\r\n            print \"Numero negativo\"\r\n\r\n        x=input(\"Ingrese un numero (\'*\' para terminar): \")\r\nY ahora lo ejecutamos:\r\n\r\n>>> pcn_loop2()\r\n\r\nIngrese un numero (\'*\' para terminar): 25\r\nNumero positivo\r\n\r\nIngrese un numero (\'*\' para terminar): 0\r\nIgual a 0\r\n\r\nIngrese un numero (\'*\' para terminar): -5\r\nNumero negativo\r\n\r\nIngrese un numero (\'*\' para terminar): \'*\'\r\n>>>\r\n', NULL),
(34, 3, '3.10', 'Formulación de algoritmos mediante mejoramiento arriba-abajo, paso a paso: Ejemplo práctico 3 (estru', 'Puede anidar un tipo de estructura de control dentro de otro tipo. En el ejemplo siguiente se usa un With bloque dentro de un For Each bucle y bloques anidados If dentro del With bloque.\r\nVB\r\n\r\nCopiar\r\nFor Each ctl As System.Windows.Forms.Control In Me.Controls  \r\n    With ctl  \r\n        .BackColor = System.Drawing.Color.Yellow  \r\n        .ForeColor = System.Drawing.Color.Black  \r\n        If .CanFocus Then  \r\n            .Text = \"Colors changed\"  \r\n            If Not .Focus() Then  \r\n                Insert code to process failed focus.  \r\n            End If  \r\n        End If  \r\n    End With  \r\nNext ctl  ', NULL),
(35, 3, '3.11', 'Operadores de asignación', 'C proporciona varios operadores de asignación para abreviar las expresiones de asignación. Por ejemplo, la instrucción\r\nc = c + 3;\r\nse puede abreviar mediante el operador de asignación de suma +=como\r\nc += 3;\r\nEl operador +=suma el valor de la expresión que se encuentra a la derecha del operador, al valor de la variable que se encuentra a la izquierda del operador y almacena el resultado en la variable que está a la izquierda del operador. Cualquier instrucción de la forma\r\n\r\nvariable = variable operador expresión;\r\n\r\nen donde el operadores uno de los operadores binarios +,-,*,/o %(u otros que explicaremos en el capítulo 10), se pueden escribir en la forma\r\nvariable operador= expresión;\r\n\r\nPor lo tanto, la asignación c += 3 suma 3 a c. La figura 3.11 muestra los operadores aritméticos de asignación, expresiones de ejemplo que utilizan estos operadores, y explicaciones\r\n                                                                                            \r\n                                                                                            =	Asignación simple\r\n*=	Asignación y multiplicación\r\n/=	Asignación y división\r\n%=	Asignación y resto\r\n+=	Asignación y suma\r\n-=	Asignación y resta\r\n<<=	Asignación y desplazamiento a la izquierda\r\n>>=	Asignación y desplazamiento a la derecha\r\n&=	Asignación AND bit a bit\r\n^=	Asignación OR exclusivo bit a bit\r\n|=	Asignación OR inclusivo bit a bit', NULL),
(36, 3, '3.12', 'Operadores de incremento y decremento', 'En lenguaje C, tanto el operador incremento (++) como el operador decremento (--) actúan siempre sobre un solo operando, normalmente una variable. Por tanto, son operadores monarios, y sirven para incrementar o decrementar en una unidad el valor de dicho operando.\r\n\r\nEjemplo 1: Declaradas las variables:\r\n\r\nint r = 8, s = 3;\r\nVariables r y s en memoria\r\nse pueden escribr las instrucciones de expresión:\r\n\r\nr++;\r\ns--;\r\n\r\nDichas instrucciones son equivalentes a:\r\n\r\nr = r + 1;\r\ns = s - 1;\r\n', NULL),
(37, 4, '4.01', 'Introduccion ', 'Estas sentencias son las que el lenguaje C utiliza para controlar el flujo de\r\nejecución del programa. Los operadores lógicos y relacionales condicionan\r\nen muchos casos estas sentencias de control', NULL),
(38, 4, '4.02', 'Fundamentos de la repetición ', 'La mayoría de los programas involucran la repetición, o ciclos. Un ciclo es un grupo de instrucciones que la\r\ncomputadora ejecuta repetidamente, mientras alguna condición de continuación de ciclo permanezca verda-\r\ndera. Hemos explicado dos medios para llevar a cabo una repetición:\r\n\r\n1. Repetición controlada por contador.\r\n2. Repetición controlada por centinela.\r\n\r\nEn algunas ocasiones, a la repetición controlada por contador se le conoce como repetición definida, ya que sa-\r\nbemos por adelantado el número exacto de veces que se ejecutará el ciclo; y a la repetición controlada por cen-\r\ntinela a veces se le llama repetición indefinida, ya que no sabemos por adelantado cuántas veces se ejecutará el\r\nciclo.\r\n\r\nEn la repetición controlada por contador, se utiliza una variable de control para contar el número de repe-\r\nticiones. La variable de control se incrementa (por lo general en 1) cada vez que el grupo de instrucciones se\r\nejecuta. Cuando el valor de la variable de control indica que el número correcto de repeticiones se ha alcanza-\r\ndo, el ciclo termina y la computadora continúa con la ejecución de la instrucción que se encuentra después de\r\nla instrucción de repetición.\r\n\r\nSe utilizan valores centinela para controlar una repetición cuando:\r\n\r\n1. No conocemos por adelantado el número preciso de repeticiones.\r\n\r\n2. El ciclo incluye instrucciones que obtienen datos, cada vez que el ciclo se ejecuta.', NULL),
(39, 4, '4.03', 'Repetición controlada por contador', 'La repetición controlada por contador requiere:\r\n1. El nombre de una variable de control (o contador de ciclo).\r\n2. El valor inicial de la variable de control.\r\n\r\n3. El incremento (o decremento) mediante el cual se modifica la variable de control cada vez que se re-\r\npite el ciclo.\r\n\r\n4. La condición que evalúa el valor final de la variable de control (es decir, si el ciclo debe continuar).\r\n\r\nConsidere el sencillo programa de la figura 4.1, el cual despliega los números del 1 al 10. La declaración\r\nint contador = 1; /* inicialización */\r\nnombra a la variable de control (contador), la declara como entero, reserva espacio en memoria para ella, y\r\n\r\nle asigna un valor inicial de 1. Esta declaración no es una instrucción ejecutable.\r\nLa declaración e inicialización de contador pudo haberse hecho con las instrucciones\r\n\r\nint contador;\r\ncontador = 1;\r\n\r\nLa declaración no es ejecutable, pero la asignación sí lo es. Nosotros utilizamos ambos métodos para inicializar variables.', NULL),
(40, 4, '4.04', 'Instrucción de repetición for', 'La instrucción for explota la capacidad del ordenador para repetir procesos y para contar. Muchas veces esta instrucción se puede reemplazar por otras instrucciones o estructuras de tipo repetición. Se podrá optar por la que se estime más oportuna, que muchas veces será la instrucción for pues reúne una cualidades interesantes.\r\n\r\nlogo lenguaje programacion C\r\n \r\n\r\nLa sintaxis a emplear con C es la siguiente:\r\n\r\nint VAR;\r\n\r\nfor (VAR = Vi; VAR<Vf; VAR++ ) {\r\n\r\nInstrucción 1;\r\n\r\nInstrucción 2;\r\n\r\n.\r\n\r\n.\r\n\r\n.\r\n\r\nInstrucción n;\r\n\r\n}', NULL),
(41, 4, '4.05', 'Instrucción de repetición for: Notas y observaciones', '\r\n1. La inicialización, la condición de continuación de ciclo y el incremento pueden contener expresiones\r\naritméticas. Por ejemplo, si x = 2 y y = 10, la instrucción:\r\n\r\nfor (j=xj]<=4*x*yj+0y/x)\r\n\r\nes equivalente a la instrucción:\r\n\r\nfor (j =2: j <= 80; j +5)\r\n\r\n2 El “incremento” puede ser negativo (en cuyo caso, en realidad sería un decremento, y el ciclo en rea-\r\nlidad contaría hacia atrás).\r\n\r\n3 Si de inicio, la condición de continuación de ciclo es falsa, la parte del cuerpo del ciclo no se ejecuta.\r\nEn su lugar, la ejecución procede con la instrucción que sigue a la instrucción for.\r\n\r\n4 La variable de control con frecuencia se imprime o se utiliza en cálculos realizados en el cuerpo del\r\nciclo, pero no tiene que ser así. Es común utilizar la variable de control para controlar la repetición,\r\nsin tener que mencionarla en el cuerpo del ciclo.\r\n\r\n5 El diagrama de flujo de una instrucción for es muy parecido al de la instrucción whi 1 e. Por ejem-\r\nplo, el diagrama de flujo de la instrucción For\r\n\r\nfor ( contador = 1; contador <= 10; contador++ )\r\nprintf( “%d”, contador );\r\n\r\n', NULL),
(42, 4, '4.06', 'Ejemplos de la utilización de la instrucción for', '\r\nCuando el número de iteraciones es conocido\r\nEjemplo: Escriba un programa que imprima los números del 1 al 30 escribiendo un salto de línea cada 7 números.\r\n\r\n#include \"stdio.h\"\r\nint main(){\r\n  int x=0;\r\n  for (x=1; x<=30; x++){\r\n    printf(\"%d 	\",x);\r\n    if (x%7==0){\r\n      printf (\"\n\");\r\n    }\r\n  }\r\n}\r\n\r\n#include \"stdio.h\"\r\nint main(){\r\n  int x=0;\r\n  for (x=1; x<=30; x++){\r\n    printf(\"%d 	\",x);\r\n    if (x%7==0){\r\n      printf (\"\n\");\r\n    }\r\n  }\r\n}\r\n \r\n\r\nExplicación: En el ejemplo anterior el número de iteraciones o vueltas está controlado por la variable x. Al ser declarada, x vale 0. Sin embargo, cuando comienza el ciclo x adquiere el valor de 1. El ciclo terminará cuando x valga 30 (x<=30). Además, x recibirá incrementos de 1 (x++).  Dentro del cuerpo de la instrucción for se imprime el valor de x (printf(“%d 	”, x)). Se evalúa si x es múltiplo de 7 (x%7==0), de ser así se imprime un salto de línea (printf (“\n”)).\r\n        \r\nCuando el número de iteraciones es determinado por el usuario.\r\nEjemplo: Escriba un programa que imprime los números del 1 a n, donde n es la cantidad de días que tiene un mes que el usuario selecciona previamente.\r\n\r\n#include \"stdio.h\"\r\nint main(){\r\n  int x, mes, dias=0;\r\n  int aa = 2017;\r\n  printf (\"Que mes desea: \");\r\n  scanf(\"%d\", &mes);\r\n  if (mes == 1|| mes == 3 || mes == 5 ||\r\n      mes == 7 || mes == 8 || mes == 10 ||\r\n      mes == 12 ){\r\n        dias = 31;\r\n      }\r\n      \r\n  for (x=1; x<=dias; x++){\r\n    printf(\"%d	\", x);\r\n    if (x % 7 == 0){\r\n        printf (\"\n\");\r\n    }\r\n  }\r\n}\r\n#include \"stdio.h\"\r\nint main(){\r\n  int x, mes, dias=0;\r\n  int aa = 2017;\r\n  printf (\"Que mes desea: \");\r\n  scanf(\"%d\", &mes);\r\n  if (mes == 1|| mes == 3 || mes == 5 ||\r\n      mes == 7 || mes == 8 || mes == 10 ||\r\n      mes == 12 ){\r\n        dias = 31;\r\n      }\r\n      \r\n  for (x=1; x<=dias; x++){\r\n    printf(\"%d	\", x);\r\n    if (x % 7 == 0){\r\n        printf (\"\n\");\r\n    }\r\n  }\r\n}\r\n \r\n\r\nExplicación: Se pregunta al usuario el mes que desesa visualizar. Si el número introducido corresponde a un mes con 31 días, la variable dias recibe el valor 31. (Se deberá incluir código si desea validar los meses con 30 días y el mes de febrero). Se inicializa el ciclo for usando la variable x con valor inicial de 1. El ciclo terminará cuando la variable x sea igual al valor de días del mes seleccionado.', NULL),
(43, 4, '4.07', 'Instrucción de selección múltiple, switch', 'El estatuto switch es una sentencia C++ que se utiliza para seleccionar una de entre múltiples alternativas.\r\n\r\nEl estatuto switch es especialmente útil cuando la selección se basa en el valor de una variable simple o de una expresión simple denominada expresión de control o selector.\r\n\r\nEl valor de esta expresión puede ser de tipo int o char, pero no pude ser del tipo float ni double.\r\n\r\nSe utiliza para ejecutar acciones diferentes según el valor de una expresión o una variable. Consiste en una serie de etiquetas case y un case por omisión default.\r\n\r\nSintaxis:\r\n\r\nswitch ( variable)     \r\n\r\n\r\n   {\r\n        case valor1 : accion1; break;\r\n       case valor2 : accion2; break;\r\n             .\r\n             .\r\n        case valor n : accionn;break;\r\n        default: accionD;\r\n    } ; \r\n\r\nLa variable es de tipo entero o caracter', NULL),
(44, 4, '4.08', 'Instrucción de repetición do..while', 'La sintaxis de un ciclo do-while es un tanto más larga que la del ciclo while en C++, sin embargo no se hace más complicado, de hecho con tan solo tener bien clara una condición de finalización para el ciclo tendremos prácticamente todo terminado.\r\n\r\n\r\ndo\r\n{\r\n        ....\r\n        ....\r\n    Bloque de Instrucciones....\r\n        ....\r\n        ....\r\n}\r\nwhile(condición de finalización); //por ejemplo numero != 23', NULL),
(45, 4, '4.09', 'Instrucciones break y continue', 'La sentencia break; dentro de cualquier bucle (for, while, etc.) fuerza la salida del bucle de forma inmediata sin esperar a su terminación natural. Esta sentencia en bucles podemos calificarla de poco habitual por cuanto rompe el flujo natural de los programas, situación que habitualmente se trata de evitar. No obstante, su uso puede resultar de interés en algunas situaciones especiales.\r\n\r\nRecordar que break; también lo usábamos en condicionales de tipo switch, donde break; hace que una vez verificado que se cumple una opción dentro del switch, se salga del mismo y se continúe la ejecución en la siguiente instrucción después del switch. Es habitual incluir un break; después de cada evaluación de un switch, aunque no es obligatorio.\r\n\r\nOtra forma de manipular el flujo en un bucle for es mediante el uso de la instrucción continue;. Con esta instrucción, insertada normalmente tras evaluar una condición, se produce el incremento automático de la variable índice y la vuelta al comienzo del bucle sin terminar la ejecución del mismo.\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n    int i=0;\r\n    for (i=0; i<5; i++) { if(i>3) {break;} //Ejemplo break\r\n        printf(\"i vale %d\\n\", i);\r\n    }\r\n    for (i=0; i<10; i++) { if(i%3==0) {continue;} //Ejemplo continue\r\n        printf(\"Ahora i vale %d\\n\", i);\r\n    }\r\n    return 0; // Curso programación C aprenderaprogramar.com\r\n}', NULL),
(46, 4, '4.10', 'Operadores lógicos', 'Los operadores lógicos no realizan las conversiones aritméticas habituales. En su lugar, evalúan cada operando para ver su equivalencia con 0. El resultado de una operación lógica es 0 o 1. El tipo del resultado es int .\r\nA continuación se describen los operadores lógicos de C:\r\n&& : El operador AND lógico genera el valor 1 si ambos operandos tienen valores distintos de cero. Si alguno de los operandos es igual a 0, el resultado es 0. Si el primer operando de una operación AND lógica es igual a 0, el segundo operando no se evalúa.\r\n|| : El operador OR lógico realiza una operación OR inclusivo en sus operandos. El resultado es 0 si ambos operandos tienen valores 0. Si cualquiera de los operandos tiene un valor distinto de cero, el resultado es 1. Si el primer operando de una operación OR lógica tiene un valor distinto de cero, el segundo operando no se evalúa.', NULL),
(47, 4, '4.11', 'La confusión entre los operadores de igualdad (==)y los de asignación (=)', 'Es necesario resaltar que el operador C++ de asignación simple (=) se distingue de otros lenguajes como Pascal que utilizan el símbolo := para este operador. Observe también que la asignación simple\r\n(=) utiliza un símbolo distinto del operador relacional de igualdad (==) ', NULL),
(48, 4, '4.12', 'Resumen sobre programacioón estructurada', 'La programación estructurada es un paradigma de programación basado en utilizar funciones o subrutinas, y únicamente tres estructuras de control:\r\n\r\nsecuencia: ejecución de una sentencia tras otra.\r\nselección o condicional: ejecución de una sentencia o conjunto de sentencias, según el valor de una variable booleana.\r\niteración (ciclo o bucle): ejecución de una sentencia o conjunto de sentencias, mientras una variable booleana sea verdadera.\r\nEste paradigma se fundamente en el teorema correspondiente, que establece que toda función computable puede ser implementada en un lenguaje de programación que combine sólo estas tres estructuras lógicas o de control.\r\n\r\nLa estructura de secuencia es la que se da naturalmente en el lenguaje, ya que por defecto las sentencias son ejecutadas en el orden en que aparecen escritas en el programa.', NULL),
(49, 5, '5.01', 'Introducción\r\n\r\n', 'Cuando un programa comienza a ser largo y complejo no es apropiado tener todas las instrucciones en un solo bloque, ya que no es fácil entender lo que hace el programa debido a que se intenta abarcar toda la solución a la vez. Además suelen aparecer secciones de código similares entre sí a lo largo de todo el programa lo que hace que el programa se vuelva aún más difícil de entender y modificar. \r\nLos lenguajes de alto nivel proporcionan herramientas para solucionar estos problemas permiten estructurar el programa principal compuesto de subprogramas (funciónes y procedimientos) que resuelven partes del problema principal. A su vez, cada uno de estos subprogramas puede estar resuelto por otro conjunto de subprogramas etc... Los procedimientos y las funciones son los mecanismos de estructuración que permiten ocultar los detalles de la solución de un problema y resolver una parte de dicho problema en otro lugar del código. \r\nEl lenguaje C utiliza bibliotecas de funciones con el fin de realizar un algunas operaciones cálculos de uso común. C además permite que el programador defina sus propias funciones para determinadas tareas. \r\n\r\nFunción: es un bloque de instrucciones que realiza tareas bien definidas. Todo programa en C consta de una o más funciones. La ejecución de un programa en C siempre comienza por la función. Cuando se ejecuta una función el control pasa al punto donde esta inicia. Una vez finalizada su ejecución, se devuelve el control al punto desde el que se hizo la llamada a la función. \r\n\r\nProcedimientos: Se llama así, en lenguaje Pascal, a un subprograma que ejecuta unas ciertas acciones sin que valor alguno de retorno esté asociado a su nombre. En otras palabras: Un procedimiento es una función que NO devuelve valores.\r\n', NULL),
(50, 5, '5.02', 'Módulos de programa en C', 'Los módulos incorporados en C++20 presentan una alternativa a la inclusión de encabezados2​ que evita las consecuencias indeseadas mencionadas y mejora la expresividad y modularidad del código. Si bien los módulos resuelven estos problemas, no fueron planteados como una mera alternativa a la inclusión de encabezado sino como una nueva capacidad de C++. Consecuencia de esto, los módulos no pueden desplazar completamente la inclusión de encabezados existentes, aunque sí pueden evitarla completamente en proyectos nuevos.\r\nEn C++20 un módulo3​ es una \"unidad de traducción\" con dos particulares relevantes:\r\ntiene un nombre de módulo declarado en el propio código\r\nes capaz de exportar símbolos (funciones, clases, etc.)\r\nA continuación se ilustra el código de un módulo elemental:\r\n \r\n1export module mi_modulo;  // nombra el módulo que se define en este archivo\r\n2export int suma(int a, int b){return a+b;}  // Sólo los elementos exportados serán accesibles or\r\n \r\nUn archivo de código que requiera utilizar las definiciones exportadas de un módulo sólo tiene que indicarlo con la instrucción:\r\nimport mi_modulo;\r\n \r\nCabe notar que, a diferencia de #include, esta forma de import no necesita indicar un nombre de archivo, sino un nombre de símbolo, específicamente un nombre de módulo, que es una entidad nueva en el lenguaje. El linker buscará ese nombre entre las unidades de traducción.\r\nEsta forma de programación, muy natural para los programadores, requiere cambios profundos en el compilador, que debe ser capaz de averiguar símbolos ajenos al archivo de código que está compilando.\r\nFragmentos globales y privados[editar]\r\nPara mayor flexibilidad C++20 permite que un módulo se desarrolle en varios archivos de código, a los que denomina fragmentos. Incluso permite manejar el nivel de visibilidad de los símbolos exportados como globales o privados, según sean accesibles por todos o solamente por otros fragmentos del mismo módulo.\r\nReemplazo de la inclusión de encabezados[editar]\r\nLa instrucción import tiene una sintaxis alternativa similar a #include:\r\nimport <iostream>;\r\n \r\nEn este caso import no nombra un módulo sino un archivo de encabezados, y lo procesa como tal. A priori parece una mera alternativa sintáctica al clásico #include, pero opera de manera diferente y más eficiente, y no es totalmente compatible. El procesamiento del encabezado se rige por algunas reglas de módulos, y como consecuencia, por ejemplo, no importa macros: import <iostream>; importa funciones, clases y variables pero no definiciones ni macros hechas con #define. Con import las directivas de preprocesador en el encabezado no tienen efecto fuera de él.\r\nNo cabe esperar que la inclusión de encabezados de bibliotecas existentes sea reemplazada por módulos, pero sí se espera que nuevas bibliotecas se escriban en términos de módulos en lugar de encabezados, y que la directiva #include vaya perdiendo protagonismo aunque no se vislumbra que se vuelva obsoleta', NULL),
(51, 5, '5.03', 'Funciones matemáticas de la biblioteca\r\n', 'El lenguaje C nos facilita una biblioteca de funciones matemáticas entre las que se incluyen las de uso más habitual como pueden ser: valor absoluto, potencia de un número elevado a otro, raíz cuadrada, funciones trigonométricas (seno, coseno, tangente, etc.), redondeo, exponenciación, logaritmo decimal, logaritmo neperiano y otras.\r\nPara utilizar las funciones matemáticas indicadas a continuación es necesario incluir en la cabecera de nuestros programas la siguiente declaración: #include <math.h>\r\nEl resultado de aplicar una función matemática es un valor numérico de tipo double (aunque el resultado puede ser un valor entero, internamente C lo considerará como un valor tipo decimal de doble precisión o tipo double)\r\nLas funciones disponibles de uso más habitual son las siguientes:\r\nFunciones Matemáticas\r\nSignificado\r\nFunciones Matemáticas\r\nSignificado\r\nfabs (x)\r\nValor absoluto de x\r\nceil (x)\r\nRedondeo entero superior\r\npow (x, y)\r\nPotencia de x elevado a y\r\nfloor (x)\r\nRedondeo entero inferior\r\nsqrt (x)\r\nRaíz cuadrada de x\r\nexp (x)\r\nExponenciación (número e elevado a x, siendo e = 2.71828)\r\nsin (x)\r\nSeno de x\r\nlog (x)\r\nLogaritmo neperiano de x\r\ncos (x)\r\nCoseno de x\r\nlog10 (x)\r\nLogaritmo decimal de x\r\ntan (x)\r\nTangente de x\r\natan (x)\r\nArcotangente de x\r\n \r\n \r\nLa biblioteca de funciones matemáticas de C es más amplia de lo que hemos expuesto (por ejemplo se dispone de más funciones trigonométricas y de otros tipos que las aquí indicadas), pero con estas funciones quedan cubiertos los cálculos más habituales.\r\nLas funciones relacionadas con ángulos trabajan en radianes. Por tanto para operar con grados habremos de realizar la conversión oportuna.\r\nVamos a comentar algunas funciones menos habituales. Respecto a ceil y floor, se trata de funciones que devuelven el redondeo entero de un número. La diferencia entre ambas es que ceil redondea al entero superior más próximo y floor redondea al entero inferior más próximo. Tener en cuenta que el entero superior más próximo a un número negativo como – 5.75 es – 5 mientras que el entero superior más próximo a un número positivo como 5.75 es 6. Recordar que aunque estas funciones devuelven enteros, internamente el tipo de datos devuelto por estas funciones en C es double. Si se aplican estas funciones a un número entero, obtenemos ese mismo número pero con formato double.\r\nC incorpora funciones que permiten generar números aleatorios así como funciones de fecha y hora. Por su importancia y extensión no las trataremos ahora.\r\nEscribe y ejecuta el código mostrado a continuación. Crea también nuevas variables y operaciones para comprobar el uso de las funciones matemáticas en C.\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\n// Ejemplo aprenderaprogramar.com\r\nint main() {\r\n	double M = -5.75; int N = 7; double Pi = 3.14159; //Equivale a 180 grados sexagesimales\r\n	printf (\"El valor absolucto de M es %g y el de N es %g\\n\", fabs(M), fabs(N));\r\n	printf (\"El coseno de Pi es %g\\n\", cos(Pi));    	printf (\"2 elevado al cubo vale %g\\n\", pow(2, 3));\r\n	printf (\"El numero pi redondeado con ceil vale %g\\n\", ceil(Pi));\r\n	printf (\"M redondeado con ceil vale %g\\n\", ceil(M));\r\n	printf (\"El numero pi redondeado con floor vale %g\\n\", floor(Pi));\r\n	printf (\"M redondeado con floor vale %g\\n\", floor(M)); printf (\"-M redondeado con floor vale %g\\n\", floor(-M));\r\n	printf (\"El numero e vale %g\\n\", exp(1)); printf (\"El logaritmo neperiano de e vale %g\\n\", log(exp(1)));\r\n	printf (\"El logaritmo decimal de 100 vale %g\\n\", log10(100));\r\n	printf (\"La raiz cuadrada de 81 vale %g\\n\", sqrt(81));\r\n	return 0;\r\n}\r\n \r\n \r\n \r\nSi vas a trabajar con constantes físicas o matemáticas te resultará de interés el empleo de const para declaración de\r\nconstantes. La ventaja de declarar una constante en vez de una variable es que la constante no puede variar en el transcurso del programa. Por tanto, se impide que por error pueda tener un valor no válido en un momento dado. Las constantes facilitan la documentación del programa y lo hacen fácil de modificar. Una declaración tipo de constante podría ser la siguiente:\r\n \r\n            	const double Pi = 3.14159; //Declara una constante de tipo double\r\n            	const char msgError [ ] =\"Verifique los datos introducidos\" ; //Declara una constante cadena\r\n \r\nExisten otros tipos de constantes y palabras reservadas relacionadas con constantes en C. De momento nos resultará suficiente el uso de const para el desarrollo de nuestros programas.\r\n \r\n \r\n \r\n \r\n \r\n \r\n', NULL),
(52, 5, '5.04', 'Funciones', 'Una función es un bloque de código que realiza alguna operación. Una función puede definir opcionalmente parámetros de entrada que permiten a los llamadores pasar argumentos a la función. Una función también puede devolver un valor como salida. Las funciones son útiles para encapsular las operaciones comunes en un solo bloque reutilizable, idealmente con un nombre que describa claramente lo que hace la función. La función siguiente acepta dos enteros de un llamador y devuelve su suma; a y b son parámetros de tipo int .\r\nC++\r\n \r\nint sum(int a, int b)\r\n{\r\n    return a + b;\r\n}\r\n \r\nSe puede invocar la función o llamarla desde cualquier número de lugares del programa. Los valores que se pasan a la función son los argumentos, cuyos tipos deben ser compatibles con los tipos de parámetro de la definición de función.\r\nC++\r\n \r\nint main()\r\n{\r\n    int i = sum(10, 32);\r\n    int j = sum(i, 66);\r\n    cout << \"The value of j is\" << j << endl; // 108\r\n}\r\n \r\nNo hay ningún límite práctico para la longitud de la función, pero un buen diseño tiene como objetivo funciones que realizan una sola tarea bien definida. Los algoritmos complejos deben dividirse en funciones más sencillas y fáciles de comprender siempre que sea posible.\r\nLas funciones definidas en el ámbito de clase se denominan funciones miembro. En C++, a diferencia de otros lenguajes, una función también pueden definirse en el ámbito de espacio de nombres (incluido el espacio de nombres global implícito). Estas funciones se denominan funciones libres o funciones no miembro; se usan en gran medida en la biblioteca estándar.\r\nLas funciones se pueden sobrecargar, lo que significa que las distintas versiones de una función pueden compartir el mismo nombre si difieren en el número o el tipo de parámetros formales. Para obtener más información, vea sobrecarga de funciones.', NULL),
(53, 5, '5.05', 'Definición de funciones\r\n', 'Una definición de función está formada por la declaración y el cuerpo de la función, entre llaves, que contiene declaraciones de variables, instrucciones y expresiones. En el ejemplo siguiente se muestra una definición de función completa:\r\nC++\r\nCopiar\r\n   int foo(int i, std::string s)\r\n    {\r\n       int value {i};\r\n       MyClass mc;\r\n       if(strcmp(s, \"default\") != 0)\r\n       {\r\n            value = mc.do_something(i);\r\n       }\r\n       return value;\r\n    }\r\n \r\nLas variables declaradas dentro del cuerpo se denominan variables locales. Se salen del ámbito cuando finaliza la función; por lo tanto, una función nunca debe devolver una referencia a una variable local.\r\nC++\r\nCopiar\r\n   MyClass& boom(int i, std::string s)\r\n    {\r\n       int value {i};\r\n       MyClass mc;\r\n       mc.Initialize(i,s);\r\n       return mc;\r\n    }\r\n \r\nfunciones const y constexpr\r\nPuede declarar una función miembro como const para especificar que la función no puede cambiar los valores de ningún miembro de datos de la clase. Al declarar una función miembro como const , ayuda al compilador a aplicar la corrección const. Si alguien intenta modificar incorrectamente el objeto con una función declarada como const , se genera un error del compilador. Para obtener más información, vea const.\r\nDeclare una función como constexpr cuando el valor que produce puede determinarse en tiempo de compilación. Una función constexpr normalmente se ejecuta más rápido que una función normal. Para obtener más información, vea constexpr.\r\nPlantillas de función\r\nUna plantilla de función es parecida a una plantilla de clase; genera funciones concretas que se basan en los argumentos de plantilla. En muchos casos, la plantilla es capaz de inferir los argumentos de tipo, por lo que no es necesario especificarlos de forma explícita.\r\nC++\r\nCopiar\r\ntemplate<typename Lhs, typename Rhs>\r\nauto Add2(const Lhs& lhs, const Rhs& rhs)\r\n{\r\n    return lhs + rhs;\r\n}\r\n \r\nauto a = Add2(3.13, 2.895); // a is a double\r\nauto b = Add2(string{ \"Hello\" }, string{ \" World\" }); // b is a std::string\r\n', NULL);
INSERT INTO `indices` (`id_indices`, `id_capitulo`, `numero_ind`, `nombre_ind`, `descripcion_ind`, `indice_id`) VALUES
(54, 5, '5.06', 'Prototipos de funciones', 'Primero recordar que en el lenguaje de Arduino al contrario que en estandar C, no es necesario declarar los prototipos de las funciones, puesto que de eso se encarga el de incluirlo el arduino builder, al igual que de añadir la función Main.\r\nEn C++ es obligatorio usar prototipos. Un prototipo es una declaración de una función. Consiste en una presentación de la función, exactamente con la misma estructura que la definición, pero sin cuerpo y terminada con un “;”. \r\nEn general, el prototipo de una función se compone de las siguientes secciones:\r\nOpcionalmente, una palabra que especifique el tipo de almacenamiento, puede ser extern o static. Si no se especifica ninguna, por defecto será extern.\r\nEl tipo del valor de retorno, que puede ser void, si no necesitamos valor de retorno.\r\nModificadores opcionales. \r\nEl identificador de la función. Es costumbre, muy útil y muy recomendable, poner nombres que indiquen, lo más claramente posible, qué es lo que hace la función, y que permitan interpretar qué hace el programa con sólo leerlos.\r\nUna lista de declaraciones de parámetros entre paréntesis. Los parámetros de una función son los valores de entrada (y en ocasiones también de salida). \r\nUn prototipo sirve para indicar al compilador los tipos de retorno y los de los parámetros de una función, de modo que compruebe si son del tipo correcto cada vez que se use esta función dentro del programa, o para hacer las conversiones de tipo cuando sea necesario.\r\nNormalmente, los prototipos de las funciones se declaran dentro del fichero del programa, o bien se incluyen desde un fichero externo, llamado fichero de cabecera, (para esto se usa la directiva #include).\r\nYa lo hemos dicho más arriba, pero las funciones son extern por defecto. Esto quiere decir que son accesibles desde cualquier punto del programa, aunque se encuentren en otros ficheros fuente del mismo programa. En contraposición las funciones declaradas static sólo son accesibles dentro del fichero fuente donde se definen.\r\nEncabezados\r\nLos nombres de los elementos de programa, como variables, funciones, clases, etc., se deben declarar antes de que se puedan utilizar. Por ejemplo, no puede simplemente escribir x = 42 sin declarar primero \"x\".\r\nC++\r\nCopiar\r\nint x; // declaration\r\nx = 42; // use x\r\n \r\nLa declaración indica al compilador si el elemento es una int , una double , una función, una class u otra cosa. Además, cada nombre se debe declarar (directa o indirectamente) en cada archivo. cpp en el que se usa. Al compilar un programa, cada archivo. cpp se compila de forma independiente en una unidad de compilación. El compilador no tiene conocimiento de los nombres que se declaran en otras unidades de compilación. Esto significa que si define una clase o una función o una variable global, debe proporcionar una declaración de ese elemento en cada archivo. cpp adicional que lo use. Cada declaración de ese elemento debe ser exactamente idéntica en todos los archivos. Una ligera incoherencia producirá errores, o un comportamiento no deseado, cuando el vinculador intente fusionar mediante combinación todas las unidades de compilación en un único programa.\r\nPara minimizar la posibilidad de errores, C++ ha adoptado la Convención de usar archivos de encabezado para contener declaraciones. Las declaraciones se realizan en un archivo de encabezado y, a continuación, se usa la Directiva #include en todos los archivos. cpp u otro archivo de encabezado que requiera dicha declaración. La Directiva #include inserta una copia del archivo de encabezado directamente en el archivo. cpp antes de la compilación.\r\n Nota\r\nEn Visual Studio 2019, la característica de módulos de c++ 20 se presenta como una mejora y un reemplazo eventual de los archivos de encabezado. Para obtener más información, vea información general sobre los módulos de C++.\r\nEjemplo\r\nEn el ejemplo siguiente se muestra una manera común de declarar una clase y, a continuación, usarla en un archivo de código fuente diferente. Comenzaremos con el archivo de encabezado, my_class.h . Contiene una definición de clase, pero tenga en cuenta que la definición está incompleta. do_something no se ha definido la función miembro:\r\nC++\r\nCopiar\r\n// my_class.h\r\nnamespace N\r\n{\r\n    class my_class\r\n    {\r\n    public:\r\n        void do_something();\r\n    };\r\n \r\n}\r\n \r\nA continuación, cree un archivo de implementación (normalmente con una extensión. cpp o similar). Llamaremos al archivo my_class. cpp y proporcionaremos una definición para la declaración de miembro. Agregamos una #include Directiva para el archivo \"my_class. h\" para que la declaración de my_class se inserte en este punto en el archivo. cpp, y se incluye para realizar la <iostream> extracción en la declaración de std::cout . Tenga en cuenta que las comillas se usan para los archivos de encabezado en el mismo directorio que el archivo de código fuente, y se usan corchetes angulares para los encabezados de la biblioteca estándar. Además, muchos encabezados de la biblioteca estándar no tienen. h ni cualquier otra extensión de archivo.\r\nEn el archivo de implementación, se puede usar opcionalmente una using instrucción para evitar tener que calificar cada mención de \"my_class\" o \"cout\" con \"N::\" o \"STD::\". No coloque using instrucciones en los archivos de encabezado.\r\nC++\r\nCopiar\r\n// my_class.cpp\r\n#include \"my_class.h\" // header in local directory\r\n#include <iostream> // header in standard library\r\n \r\nusing namespace N;\r\nusing namespace std;\r\n \r\nvoid my_class::do_something()\r\n{\r\n    cout << \"Doing something!\" << endl;\r\n}\r\n \r\nAhora podemos usar my_class en otro archivo. cpp. #Include el archivo de encabezado para que el compilador Extraiga la declaración. Todo el compilador debe saber que my_class es una clase que tiene una función miembro pública denominada do_something() .\r\nC++\r\nCopiar\r\n// my_program.cpp\r\n#include \"my_class.h\"\r\n \r\nusing namespace N;\r\n \r\nint main()\r\n{\r\n    my_class mc;\r\n    mc.do_something();\r\n    return 0;\r\n}\r\n \r\nUna vez que el compilador termina de compilar cada archivo. cpp en archivos. obj, pasa los archivos. obj al enlazador. Cuando el vinculador combina los archivos objeto, encuentra exactamente una definición para my_class; está en el archivo. obj generado para my_class. cpp y la compilación se realiza correctamente.\r\nIncluir protecciones\r\nNormalmente, los archivos de encabezado tienen una protección de inclusión o una #pragma once Directiva para asegurarse de que no se insertan varias veces en un único archivo. cpp.\r\nC++\r\nCopiar\r\n// my_class.h\r\n#ifndef MY_CLASS_H // include guard\r\n#define MY_CLASS_H\r\n \r\nnamespace N\r\n{\r\n    class my_class\r\n    {\r\n    public:\r\n        void do_something();\r\n    };\r\n}\r\n \r\n#endif /* MY_CLASS_H */\r\n', NULL),
(55, 5, '5.07', 'Encabezados\r\n', 'Dado que un archivo de encabezado podría estar incluido potencialmente en varios archivos, no puede contener definiciones que puedan generar varias definiciones del mismo nombre. Los siguientes elementos no están permitidos o se consideran muy incorrectos:\r\ndefiniciones de tipos integrados en un espacio de nombres o ámbito global\r\ndefiniciones de funciones no insertadas\r\ndefiniciones de variables no const\r\ndefiniciones de agregado\r\nespacios de nombres sin nombre\r\nDirectivas using\r\nEl uso de la using Directiva no producirá necesariamente un error, pero puede causar un problema, ya que pone el espacio de nombres en el ámbito de cada archivo. cpp que incluye directa o indirectamente ese encabezado.\r\nArchivo de encabezado de ejemplo\r\nEn el ejemplo siguiente se muestran los distintos tipos de declaraciones y definiciones que se permiten en un archivo de encabezado:\r\nC++\r\nCopiar\r\n// sample.h\r\n#pragma once\r\n#include <vector> // #include directive\r\n#include <string>\r\n \r\nnamespace N  // namespace declaration\r\n{\r\n    inline namespace P\r\n    {\r\n        //...\r\n    }\r\n \r\n    enum class colors : short { red, blue, purple, azure };\r\n \r\n    const double PI = 3.14;  // const and constexpr definitions\r\n    constexpr int MeaningOfLife{ 42 };\r\n    constexpr int get_meaning()\r\n    {\r\n        static_assert(MeaningOfLife == 42, \"unexpected!\"); // static_assert\r\n        return MeaningOfLife;\r\n    }\r\n    using vstr = std::vector<int>;  // type alias\r\n    extern double d; // extern variable\r\n \r\n#define LOG   // macro definition\r\n \r\n#ifdef LOG   // conditional compilation directive\r\n    void print_to_log();\r\n#endif\r\n \r\n    class my_class   // regular class definition,\r\n    {                // but no non-inline function definitions\r\n \r\n        friend class other_class;\r\n    public:\r\n        void do_something();   // definition in my_class.cpp\r\n        inline void put_value(int i) { vals.push_back(i); } // inline OK\r\n \r\n    private:\r\n        vstr vals;\r\n        int i;\r\n    };\r\n \r\n    struct RGB\r\n    {\r\n        short r{ 0 };  // member initialization\r\n        short g{ 0 };\r\n        short b{ 0 };\r\n    };\r\n \r\n    template <typename T>  // template definition\r\n    class value_store\r\n    {\r\n    public:\r\n        value_store<T>() = default;\r\n        void write_value(T val)\r\n        {\r\n            //... function definition OK in template\r\n        }\r\n    private:\r\n        std::vector<T> vals;\r\n    };\r\n \r\n    template <typename T>  // template declaration\r\n    class value_widget;\r\n}\r\n \r\n', NULL),
(56, 5, '5.08', 'Llamada a funciones: Llamada por valor y llamada por referencia\r\n', ' \r\nLlamada por valor\r\nYa conocemos las funciones en las que llamamos por valor. Cabe mencionar que esto sólo aplica a las funciones que reciben argumentos.\r\nEn esas funciones, una copia de la variable es creada dentro de la llamada de la función, y no afecta a la original. Veamos este ejemplo de una función que incrementa un entero:\r\nint incrementar(int numero){\r\n	//Incrementar en 1\r\n	numero = numero + 1;\r\n}\r\n \r\nNo estamos devolviendo nada, estamos simplemente alterando a la variable que recibimos. Ahora lo llamamos así:\r\n \r\n#include<stdio.h>\r\n \r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint incrementar(int numero);\r\n \r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero = 10;\r\n	printf(\"Antes de llamar a la funcion, numero es %d\\n\", numero);\r\n	incrementar(numero);\r\n	printf(\"Despues de llamar a la funcion, numero es %d\", numero);\r\n}\r\n \r\n// Ahora sí definimos la función con todo y cuerpo\r\nint incrementar(int numero){\r\n	//Incrementar en 1\r\n	numero = numero + 1;\r\n}\r\n \r\nLa salida del programa es:\r\nAntes de llamar a la funcion, numero es 10\r\nDespues de llamar a la funcion, numero es 10\r\nComo vemos, se crea una nueva variable dentro de la función. Y aunque afectemos a la misma, la variable original sigue intacta. Esto es a lo que referimos cuando pasamos variables por valor.\r\nLlamada por referencia\r\nUna llamada por referencia ocurre cuando no pasamos el nombre de la variable, sino su dirección. En este caso no se crea una nueva variable.\r\nModifiquemos la función para que ahora reciba el puntero o apuntador a una variable, no una variable en sí. Quedaría así:\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\nAhora recibiremos direcciones de variables. Y al incrementar, incrementamos el valor que haya en la dirección que dijimos.\r\nCorremos el programa con esto:\r\n#include<stdio.h>\r\n \r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint incrementar(int *numero);\r\n \r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero = 10;\r\n	printf(\"Antes de llamar a la funcion, numero es %d\\n\", numero);\r\n \r\n	// Con el operador & obtenemos la dirección de numero\r\n	incrementar(&numero);\r\n	printf(\"Despues de llamar a la funcion, numero es %d\", numero);\r\n}\r\n \r\n// Ahora sí definimos la función con todo y cuerpo\r\n//Notar el * antes de numero\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\n \r\n\r\n \r\n', NULL),
(57, 5, '5.09', 'Generación de números aleatorios\r\n', 'GENERAR NÚMEROS ALEATORIOS EN C: SRAND Y RAND\r\nLa generación de números aleatorios adquiere gran relevancia para un programador, pudiendo usarse para distintas tareas de las que vamos a citar algunas, aunque hay tantas posibilidades que resultan prácticamente infinitas. \r\n- Construcción preliminar de programas, en los que a falta de datos definitivos introducimos datos aleatorios.\r\n- Simular procesos aleatorios (número resultante de tirar un dado, elección de un color por parte de una persona, número premiado en un sorteo de lotería, cantidad de personas que entran a un supermercado en una hora...)\r\n- Verificación de programas, haciendo pruebas con datos aleatorios.\r\n- Otras aplicaciones.\r\n \r\nConviene recordar que \"aleatorio\" no puede confundirse con \"cualquier cosa\", \"descontrol\", \"incierto\", \"impredecible\", etc. Usaremos aleatorio más en el sentido de no predeterminado que en el de no predecible, ya que en general vamos a definir qué tipo de resultado queremos obtener y en qué rango de valores debe estar. Vamos a imaginar que el lenguaje C genera números aleatorios como si fuera un robot lanzador de dardos muy preciso (“robot”rand). De este modo, cuando se le dice que comience a tirar dardos en distintas posiciones, repite siempre los lugares. Por ejemplo, si la diana está marcada con números, cada vez que le decimos que tire genera la misma secuencia: 7, 5, 6, 3, etc. ¿Cómo conseguir convertir este proceso predefinido en aleatorio? Pues simplemente poniendo a girar la diana (“mayordomo”srand) esta vez a una velocidad que depende del segundo del día en que nos encontremos. Así pues, el proceso lo dividimos en decirle al mayordomo que ponga a girar la diana y en decirle al robot que dispare. Bueno, no es una explicación técnica, pero ¿para qué complicarnos? Veamos la sintaxis a emplear:\r\n \r\n1)	Asignación de valor aleatorio a una variable.\r\nsrand (time(NULL));   	[Instrucción que inicializa el generador de números aleatorios]\r\nint variable = rand(); 	[Obtención de un número aleatorio entero entre cero y un valor muy grande]\r\n \r\n2)	Mostrar un valor aleatorio.\r\nsrand (time(NULL));\r\nprintf (\"%d\\n\",rand());\r\n \r\nEl valor devuelto por rand() es de tipo entero, aunque si la variable a la que se asigna el contenido de rand() es de otro tipo, tendrá lugar la conversión del valor originario para adaptarlo al tipo de variable de que se trate. Un aspecto importante a tener en cuenta es que el valor devuelto se encuentra en el rango 0<= valor < constante numérica RAND_MAX. Es decir, el número devuelto puede ser cero o un valor cualquiera hasta el límite que define una constante de C (que podemos conocer escribiendo printf(\"%d\", RAND_MAX);. Ejecuta este código y comprueba los resultados:\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n// Ejemplo aprenderaprogramar.com\r\nint main() {\r\nsrand(time(NULL)); //El mayordomo pone a girar la diana\r\nint test = rand(); //Primer disparo del robot\r\nprintf (\"El numero aleatorio de test vale %d\\n\", test);\r\nprintf (\"Otros numeros aleatorios son: %d, %d, %d\\n\",rand(),rand(),rand()) ;\r\nprintf(\"La constante RAND_MAX vale %d\\n\", RAND_MAX);\r\nreturn 0;\r\n}\r\n \r\n \r\nUn posible resultado con este programa es: El numero aleatorio de test vale 21051. Otros numeros aleatorios son: 12546, 22788, 7054. La constante RAND_MAX vale 32767.\r\nSi repites la ejecución del programa obtendrás otros valores distintos, excepto el de la constante RAND_MAX que como su propio nombre indica es fijo (para un sistema y compilador dados).\r\nLa sentencia time(NULL) devuelve el número de segundos que han pasado desde el 1 de enero de 1970 según el reloj del sistema y nosotros la veremos como un número a partir del que se genera la velocidad de giro de la diana. Siempre será distinto porque nunca ejecutaremos un programa en el mismo segundo en que se ejecutó anteriormente. La sentencia srand(valor); la veremos como la instrucción que pone a girar la diana a una velocidad calculada a partir del número indicado en el parámetro “valor”.\r\nLas funciones srand y rand están disponibles gracias a la directiva del preprocesador stdlib.h. Para poder hacer uso de la función time hemos de incluir la línea #include <time.h>, que es la que nos facilita el uso de las funciones relacionadas con el tiempo en C.\r\nEn muchos casos querremos obtener un número con un valor máximo acotado: por ejemplo un número aleatorio entre 0 y 3. Para ello nos podemos valer de la operación matemática que nos devuelve el resto de una división entera, que en C se expresa con el símbolo % y que hemos denominado operación de módulo o de obtención del resto. Por ejemplo 6%3 es el resto de dividir 6 entre 3. Como la división es exactamente 2, el resto es 0. En cambio 7%3 genera un resto 1. 8%3 genera un resto 2 y 9%3 genera un resto 0 nuevamente.\r\nSi nos fijamos los valores posibles al hacer la operación Numero%3 son 0 (la división es exacta), 1 (el resto es 1) ó 2 (el resto es 2). En ningún caso el resto podría ser 3 ni un valor superior a 3. Basándonos en esto podemos obtener números aleatorios entre 0 (incluido) y un número NUM (incluido) haciendo la operación módulo al número aleatorio que nos devuelve rand() así: rand%(NUM+1)\r\nPor ejemplo: para obtener un número aleatorio comprendido entre 0 y 10 escribiríamos rand()%11. El resultado de esta operación será 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ó 10.\r\nEjecuta este código varias veces y comprueba cómo varían los resultados:\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n// Ejemplo aprenderaprogramar.com\r\nint main() {\r\nsrand(time(NULL)); //El mayordomo pone a girar la diana\r\nint test = rand() % 5; //Primer disparo del robot\r\nprintf(\"Numero aleatorio entre 0 y 4 es %d\\n\" ,test);\r\nprintf(\"Otros aleatorios entre 0 y 4 son %d, %d, %d\\n\" ,rand()%5,rand()%5,rand()%5);\r\nprintf(\"Otros mas son %d, %d, %d\\n\" ,rand()%5,rand()%5,rand()%5);\r\nreturn 0;\r\n}\r\n \r\n \r\nFinalmente también será habitual que además de tener un extremo superior, también queramos tener un valor mínimo inferior. Por ejemplo para simular la tirada de un dado necesitaremos que el número mínimo sea un 1 y el número máximo un 6. Esto lo podemos simular escribiendo rand()%6+1. En este caso rand()%6 nos devuelve 0, 1, 2, 3, 4 ó 5. Al sumarle un 1 estaremos obteniendo siempre alguno de los valores deseados: 1, 2, 3, 4, 5 ó 6.\r\nSi quisiéramos obtener números entre 20 y 30 escribiríamos rand()%11+20. La componente fija 20 nos da el mínimo y el módulo nos da números comprendidos entre 0 y 10 de modo que el valor mínimo es 20 y el máximo 30. La fórmula general sería rand()%(INTERVALO+1)+MINIMO\r\nUna instrucción srand puede utilizarse para múltiples rand. De todas formas, si es un programa extenso y tienes dudas, puedes poner un srand asociado a cada uno de los rand o grupos de rand que tengas en distintas partes del programa. De esta manera reduces el “determinismo” o posibilidad de repetición de ciertos valores o intervalos que podrían resultar poco adecuados para representar aleatoriedad.\r\nLa generación de números aleatorios puede presentar problemas cuya base es matemática. Estos problemas pueden ser del tipo “que la aleatoriedad no sea uniforme en el rango deseado”. Por ejemplo, si generamos números entre 1 y 100 querremos que cualquier número tenga igual probabilidad de salir siempre que esté dentro del rango. Sin embargo, puede ocurrir que ciertos números tengan mayor probabilidad de salir debido a las cuestiones matemáticas que subyacen a este respecto. La serie que obtienes puede ser “aparentemente aleatoria” y sin embargo no estar uniformemente distribuida. En algunos casos esto puede considerarse aceptable, pero en otros no. Nosotros no vamos a profundizar en el estudio matemático de la generación de aleatorios y nos resulta suficiente el tratamiento que hemos visto, pero si tuvieras que realizar programas donde es importante el aspecto matemático, deberás estudiar más a fondo el funcionamiento de los números aleatorios en C.\r\n \r\n \r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <time.h>\r\n \r\nint apuesta;\r\n', NULL),
(58, 5, '5.10', 'Ejemplo: Un juego de azar \r\n', 'int apuesta_c;\r\nint vidas=5; .\r\nbool a=1; //no se si use bien esto, pero el punto era darle un nombre a lo que el bucle va repetir más adelante.\r\n \r\nusing namespace std;\r\n \r\nint main(){\r\n	srand(time(NULL));\r\n	if(vidas!=0)\r\n	{\r\n		for(a=1;vidas!=0;a++)\r\n		{\r\n			cout << \"Vidas: \" << vidas << \"\\n\" << endl;\r\n			cout << \"Apuesta!\" << endl;\r\n			scanf(\"%d\", &apuesta);\r\n			apuesta_c = rand() %10;\r\n				if (apuesta==apuesta_c)\r\n					{\r\n						cout << \"Felicidades. +1 \\n\" << endl;\r\n						vidas=vidas+1;\r\n					}\r\n					else\r\n					{\r\n						cout << \"Has perdido, apuesta de la computadora: \" << apuesta_c << endl;\r\n						vidas=vidas-1;\r\n					}\r\n		}\r\n	}\r\n	else\r\n	{\r\n		cout << \"FIN DEL JUEGO\" << endl;\r\n	}\r\n	system(\"PAUSE\");\r\n	return 0;\r\n \r\n}\r\n \r\n \r\n \r\n \r\n', NULL),
(59, 5, '5.11', 'Clases de almacenamiento\r\n', 'Una clase de almacenamiento en el contexto de las declaraciones de variables de C++ es un especificador de tipo que rige la duración, la vinculación y la ubicación de la memoria de los objetos. Un objeto determinado puede tener solo una clase de almacenamiento. Las variables definidas dentro de un bloque tienen almacenamiento automático, a menos que se especifique lo contrario mediante los extern static thread_local especificadores, o. Las variables y objetos automáticos no tienen ninguna vinculación; no son visibles para código fuera del bloque. La memoria se asigna automáticamente cuando la ejecución entra en el bloque y se anula la asignación cuando se sale del bloque.\r\nNotas\r\nLa palabra clave mutable puede considerarse un especificador de clase de almacenamiento. Sin embargo, solo está disponible en la lista de miembros de una definición de clase.\r\nVisual Studio 2010 y versiones posteriores: La auto palabra clave ya no es un especificador de clase de almacenamiento de C++ y la register palabra clave está en desuso. Visual Studio 2017 versión 15,7 y versiones posteriores: (disponible con /std:c++17 ): la register palabra clave se quita del lenguaje C++.\r\nC++\r\nCopiar\r\n  register int val; // warning C5033: \'register\' is no longer a supported storage class\r\n \r\nstatic\r\nLa static palabra clave se puede utilizar para declarar variables y funciones en el ámbito global, el ámbito de espacio de nombres y el ámbito de clase. También se pueden declarar variables estáticas en el ámbito local.\r\nDuración estática significa que el objeto o la variable se asignan cuando se inicia el programa y se desasignan cuando finaliza el programa. Vinculación externa significa que el nombre de la variable puede verse desde fuera del archivo en el que se declara la variable. A la inversa, la vinculación interna significa que el nombre no es visible fuera del archivo en el que se declara la variable. De forma predeterminada, una variable o un objeto que se defina en el espacio de nombres global tiene duración estática y vinculación externa. La static palabra clave se puede usar en las siguientes situaciones.\r\nCuando se declara una variable o función en el ámbito de archivo (ámbito global o de espacio de nombres), la static palabra clave especifica que la variable o función tiene vinculación interna. Cuando se declara una variable, la variable tiene duración estática y el compilador la inicializa como 0, a menos que se especifique otro valor.\r\nCuando se declara una variable en una función, la static palabra clave especifica que la variable mantiene su estado entre las llamadas a esa función.\r\nCuando se declara un miembro de datos en una declaración de clase, la static palabra clave especifica que todas las instancias de la clase comparten una copia del miembro. Un miembro de datos estático se debe definir en el ámbito de archivo. Un miembro de datos entero que se declara como const static puede tener un inicializador.\r\nCuando se declara una función miembro en una declaración de clase, la static palabra clave especifica que todas las instancias de la clase comparten la función. Una función miembro estática no puede tener acceso a un miembro de instancia porque la función no tiene un this puntero implícito. Para tener acceso a un miembro de instancia, declare la función con un parámetro que sea un puntero o referencia de instancia.\r\nNo puede declarar los miembros de una unión como estáticos. Sin embargo, se debe declarar explícitamente una Unión anónima declarada globalmente static .\r\nEn este ejemplo se muestra cómo una variable declarada static en una función conserva su estado entre las llamadas a esa función.\r\nC++\r\n \r\n \r\n// static1.cpp\r\n// compile with: /EHsc\r\n#include <iostream>\r\n \r\nusing namespace std;\r\nvoid showstat( int curr ) {\r\n   static int nStatic;    // Value of nStatic is retained\r\n                          // between each function call\r\n   nStatic += curr;\r\n   cout << \"nStatic is \" << nStatic << endl;\r\n}\r\n \r\nint main() {\r\n   for ( int i = 0; i < 5; i++ )\r\n      showstat( i );\r\n}\r\n \r\nOutput\r\nCopiar\r\nnStatic is 0\r\nnStatic is 1\r\nnStatic is 3\r\nnStatic is 6\r\nnStatic is 10\r\n \r\nEn este ejemplo se muestra el uso de static en una clase.\r\nC++\r\nCopiar\r\n// static2.cpp\r\n// compile with: /EHsc\r\n#include <iostream>\r\n \r\nusing namespace std;\r\nclass CMyClass {\r\npublic:\r\n   static int m_i;\r\n};\r\n \r\nint CMyClass::m_i = 0;\r\nCMyClass myObject1;\r\nCMyClass myObject2;\r\n \r\nint main() {\r\n   cout << myObject1.m_i << endl;\r\n   cout << myObject2.m_i << endl;\r\n \r\n   myObject1.m_i = 1;\r\n   cout << myObject1.m_i << endl;\r\n   cout << myObject2.m_i << endl;\r\n \r\n   myObject2.m_i = 2;\r\n   cout << myObject1.m_i << endl;\r\n   cout << myObject2.m_i << endl;\r\n \r\n   CMyClass::m_i = 3;\r\n   cout << myObject1.m_i << endl;\r\n   cout << myObject2.m_i << endl;\r\n}\r\n \r\nOutput\r\nCopiar\r\n0\r\n0\r\n1\r\n1\r\n2\r\n2\r\n3\r\n3\r\n \r\nEn este ejemplo se muestra una variable local declarada static en una función miembro. La static variable está disponible para el programa completo; todas las instancias del tipo comparten la misma copia de la static variable.\r\nC++\r\nCopiar\r\n// static3.cpp\r\n// compile with: /EHsc\r\n#include <iostream>\r\nusing namespace std;\r\nstruct C {\r\n   void Test(int value) {\r\n      static int var = 0;\r\n      if (var == value)\r\n         cout << \"var == value\" << endl;\r\n      else\r\n         cout << \"var != value\" << endl;\r\n \r\n      var = value;\r\n   }\r\n};\r\n \r\nint main() {\r\n   C c1;\r\n   C c2;\r\n   c1.Test(100);\r\n   c2.Test(100);\r\n}\r\n \r\nOutput\r\nCopiar\r\nvar != value\r\nvar == value\r\n \r\nA partir de C++ 11, static se garantiza que la inicialización de una variable local es segura para subprocesos. Esta característica se denomina a veces estáticas mágicas. Sin embargo, en una aplicación con subprocesamiento múltiple todas las asignaciones posteriores deben estar sincronizadas. La característica de inicialización estática segura para subprocesos se puede deshabilitar mediante la /Zc:threadSafeInit- marca para evitar la realización de una dependencia en CRT.\r\nextern\r\nLos objetos y las variables que se declaran como declaran extern un objeto que se define en otra unidad de traducción o en un ámbito de inclusión como una vinculación externa. Para obtener más información, consulte extern y unidades de traducción y vinculación.\r\nthread_local(C++ 11)\r\nUna variable declarada con el thread_local especificador solo es accesible en el subproceso en el que se crea. La variable se crea cuando se crea el subproceso y se destruye cuando se destruye el subproceso. Cada subproceso tiene su propia copia de la variable. En Windows, thread_local es funcionalmente equivalente al atributo específico de Microsoft __declspec( thread ) .\r\nC++\r\nCopiar\r\nthread_local float f = 42.0; // Global namespace. Not implicitly static.\r\n \r\nstruct S // cannot be applied to type definition\r\n{\r\n    thread_local int i; // Illegal. The member must be static.\r\n    thread_local static char buf[10]; // OK\r\n};\r\n \r\nvoid DoSomething()\r\n{\r\n    // Apply thread_local to a local variable.\r\n    // Implicitly \"thread_local static S my_struct\".\r\n    thread_local S my_struct;\r\n}\r\n \r\nAspectos que se deben tener en cuenta sobre el thread_local especificador:\r\nEs posible que las variables locales de subproceso inicializadas dinámicamente en archivos dll no se inicialicen correctamente en todos los subprocesos de llamada. Para obtener más información, vea thread.\r\nEl thread_local especificador se puede combinar con static o extern .\r\nSolo se puede aplicar thread_local a declaraciones y definiciones de datos; thread_local no se puede usar en declaraciones o definiciones de función.\r\nSolo se puede especificar thread_local en elementos de datos con duración de almacenamiento estática. Esto incluye los objetos de datos globales ( static y extern ), los objetos estáticos locales y los miembros de datos estáticos de las clases. Cualquier variable local declarada thread_local es implícitamente estática Si no se proporciona ninguna otra clase de almacenamiento; es decir, en el ámbito de bloque thread_local es equivalente a thread_local static .\r\nDebe especificar thread_local para la declaración y la definición de un objeto local de subproceso, ya sea que la declaración y la definición se produzcan en el mismo archivo o en archivos independientes.\r\nEn Windows, thread_local es funcionalmente equivalente a __declspec(thread) , excepto *__declspec(thread) en que * se puede aplicar a una definición de tipo y es válido en código C. Siempre que sea posible, use thread_local porque forma parte del estándar de C++ y, por lo tanto, es más portátil.\r\nel\r\nVisual Studio 2017 versión 15,3 y posterior (disponible con /std:c++17 ): la register palabra clave ya no es una clase de almacenamiento admitida. La palabra clave todavía está reservada en el estándar para su uso futuro.\r\nC++\r\nCopiar\r\n  register int val; // warning C5033: \'register\' is no longer a supported storage class\r\n \r\nEjemplo: inicialización automática frente a inicialización estática\r\nUna variable o un objeto automático local se inicializa cada vez que el flujo de control alcanza su definición. Una variable o un objeto estático local se inicializa la primera vez que el flujo de control alcanza su definición.\r\nConsidere el ejemplo siguiente, que define una clase que registra la inicialización y la destrucción de objetos y, a continuación, define tres objetos, I1, I2 e I3:\r\nC++\r\nCopiar\r\n// initialization_of_objects.cpp\r\n// compile with: /EHsc\r\n#include <iostream>\r\n#include <string.h>\r\nusing namespace std;\r\n \r\n// Define a class that logs initializations and destructions.\r\nclass InitDemo {\r\npublic:\r\n    InitDemo( const char *szWhat );\r\n    ~InitDemo();\r\n \r\nprivate:\r\n    char *szObjName;\r\n    size_t sizeofObjName;\r\n};\r\n \r\n// Constructor for class InitDemo\r\nInitDemo::InitDemo( const char *szWhat ) :\r\n    szObjName(NULL), sizeofObjName(0) {\r\n    if ( szWhat != 0 && strlen( szWhat ) > 0 ) {\r\n        // Allocate storage for szObjName, then copy\r\n        // initializer szWhat into szObjName, using\r\n        // secured CRT functions.\r\n        sizeofObjName = strlen( szWhat ) + 1;\r\n \r\n        szObjName = new char[ sizeofObjName ];\r\n        strcpy_s( szObjName, sizeofObjName, szWhat );\r\n \r\n        cout << \"Initializing: \" << szObjName << \"\\n\";\r\n    }\r\n    else {\r\n        szObjName = 0;\r\n    }\r\n}\r\n \r\n// Destructor for InitDemo\r\nInitDemo::~InitDemo() {\r\n    if( szObjName != 0 ) {\r\n        cout << \"Destroying: \" << szObjName << \"\\n\";\r\n        delete szObjName;\r\n    }\r\n}\r\n \r\n// Enter main function\r\nint main() {\r\n    InitDemo I1( \"Auto I1\" ); {\r\n        cout << \"In block.\\n\";\r\n        InitDemo I2( \"Auto I2\" );\r\n        static InitDemo I3( \"Static I3\" );\r\n    }\r\n    cout << \"Exited block.\\n\";\r\n}\r\n \r\nOutput\r\nCopiar\r\nInitializing: Auto I1\r\nIn block.\r\nInitializing: Auto I2\r\nInitializing: Static I3\r\nDestroying: Auto I2\r\nExited block.\r\nDestroying: Auto I1\r\nDestroying: Static I3\r\n \r\nEn este ejemplo se muestra cómo y cuándo I1 se I2 inicializan los objetos, y I3 cuando se destruyen.\r\nHay varios puntos que se deben tener en cuenta sobre el programa:\r\n\r\nEn primer lugar, I1 e I2 se destruyen automáticamente cuando el flujo de control sale del bloque en el que están definidos.\r\nEn segundo lugar, en C++, no es necesario declarar objetos o variables al principio de un bloque. Además, estos objetos se inicializan solo cuando el flujo de control alcanza sus definiciones. ( I2 y I3 son ejemplos de estas definiciones). El resultado se muestra exactamente cuando se inicializan.\r\nPor último, las variables locales estáticas como I3 conservan sus valores mientras dura el programa, pero se destruyen cuando el programa finaliza.\r\n', NULL),
(60, 5, '5.12', 'Reglas de alcance', 'El alcance de un nombre es la parte del programa en la cual el nombre est´a definido. Para una variable autom´atica declarada en una funci´on el alcance es la funci´on en la cual el nombre est´a declarado y variables con el mismo nombre en distintas funciones no est´an relacionadas. Lo mismo es cierto para los argumentos de la funci´on. El alcance de una variable externa es desde el punto en el cual es definida en un archivo hasta el final del archivo. Si necesitamos referenciar una variable 2 externa antes de ser definida o si es utilizada en un archivo distinto es necesario colocar la declaraci´on extern\r\n', NULL),
(61, 5, '5.12', 'Reglas de alcance', 'El alcance de un nombre es la parte del programa en la cual el nombre est´a definido. Para una variable autom´atica declarada en una funci´on el alcance es la funci´on en la cual el nombre est´a declarado y variables con el mismo nombre en distintas funciones no est´an relacionadas. Lo mismo es cierto para los argumentos de la funci´on. El alcance de una variable externa es desde el punto en el cual es definida en un archivo hasta el final del archivo. Si necesitamos referenciar una variable 2 externa antes de ser definida o si es utilizada en un archivo distinto es necesario colocar la declaraci´on extern\r\n \r\n', NULL),
(62, 5, '5.13', 'Recursividad\r\n', 'Una función recursiva es aquella que se llama a sí misma. Sabemos que este concepto a primeras no es fácil de comprender, por eso lo vamos a tratar de explicar lo mejor posible.\r\n \r\nEstá la recursividad o recursión directa, que es el proceso por el cual una función se llama a sí misma desde el propio cuerpo de la función. También está la recursividad o recursión indirecta, la cual implica más de una función.\r\n \r\n \r\nPara dar un ejemplo de la recursividad indirecta piensa en la función main(), esta por su parte llama a una función que se llama funcionUno(), a continuación, funcionUno() llama a otra función con el nombre de funcionDos(). Ahora, en algún punto del programa, funcionDos() llama a funcionUno(), esto sería una segunda llamada de funcionUno(). A esto se le conoce como recursión indirecta, pero recursiva, ya que funcionUno() ha sido llamada dos veces sin retornar ningún valor.\r\n \r\nPara dar un ejemplo de la recursividad directa, pensaremos en el factorial de un número, en este curso hemos visto diferentes maneras de resolver este problema, pero hay más, incluso una forma más eficiente.\r\n \r\nSabemos que el factorial de un número n es igual a:\r\n \r\nn! = n * (n - 1) * (n – 2) * . . . * 3 * 2 * 1\r\n \r\n¿Qué queremos decir con esto? Que si pensamos en el factorial de 5, debemos saber que eso es:\r\n \r\n5! = 5 * 4 *3 * 2 * 1\r\n \r\no lo que es igual a:\r\n \r\n5! = 5 * (5 – 1) * (5 – 2) * (5 - 3) * (5 -4)\r\n \r\nCon esto podemos concluir que, si queremos sacar el factorial de 5, debemos saber cuánto es el factorial de 4, y para sacar el factorial de 4, debemos a su vez, saber cuánto es el factorial de 3 y así sucesivamente hasta tener que saber cuánto es el factorial de 1, que por supuesto, es 1.\r\n \r\nEntonces podríamos pensar en lo siguiente:\r\n \r\n5! = 5 * 4!\r\n \r\n4! = 4 * 3!\r\n \r\n3! = 3 * 2!\r\n \r\n2! = 2 * 1!\r\n \r\n1! = 1\r\n \r\nEntonces, ya que sabemos cuánto es el factorial de 1\r\n \r\n2! = 2 * 1! = 2 * 1 = 2\r\n \r\n3! = 3 * 2! = 3 * 2 = 6\r\n \r\n4! = 4 * 3! = 4 * 6 = 24\r\n \r\n5! = 5 * 4! = 5 * 24 = 120\r\n \r\nY exactamente esto es una función recursiva, y su implementación sería la siguiente:\r\n \r\n#include &ltiostream&gt\r\nusing namespace std;\r\n \r\ndouble factorial(int numero);\r\n \r\nint main(){\r\n    int numero;\r\n    cout &lt&lt \"Introduzca numero: \";\r\n    cin &gt&gt numero;\r\n    cout &lt&lt \"factorial: \" &lt&lt factorial(numero) &lt&lt endl;\r\n \r\n    return 0;\r\n}\r\n \r\ndouble factorial(int numero){\r\n    if (numero == 1){\r\n        return 1;\r\n    }else{\r\n        return numero*factorial(numero-1);\r\n    }\r\n}\r\n \r\n \r\nEs un poco enredado y te puedes estar preguntando, qué pasa en esa función, lo explicamos paso a paso.\r\n \r\nSe llama la función factorial() desde el main(), en la función, entra como parámetro un número entero (int) y hay una condición, si ese número es igual a 1, entonces la función va a retornar el valor de 1.\r\n \r\nif (numero == 1){\r\nreturn 1;\r\n}\r\n \r\n¿Pero qué ocurre si ese valor es mayor a 1? Entonces entra en el bloque else y como pueden notar, en ese bloque se llama nuevamente a la misma función y de parámetro se envía el mismo número pero restandole 1.\r\n \r\nelse{\r\nreturn (numero*factorial(numero-1));\r\n}\r\n \r\nVamos a simular el proceso con el número 4. Supongamos que ese es el número que enviamos desde la función principal. El número 4 entra en la función factorial y se evalúa la condición\r\n \r\n¿El número es igual a 1? Por supuesto que no. Pasamos al bloque else, entonces la función va a retornar el mismo número multiplicado por factorial(numero – 1), el parámetro (numero – 1) es igual a 3, entonces quedaría:\r\n \r\nreturn 4 * factorial(3);\r\n \r\nComo se ha llamado de nuevo la función, se realiza el mismo proceso, se avalúa la condición\r\n \r\n¿El número es igual a 1? Por supuesto que no. Pasamos al bloque else y hacemos exactamente lo mismo que la vez anterior, nos va a quedar lo siguiente.\r\n \r\nreturn 3 * factorial(2);\r\n \r\nAhora es 2 el número que se pasa a la función, ya que la hemos vuelto a llamar, haremos el mismo proceso que hemos hecho.\r\n \r\n¿El número es igual a 1? Por supuesto que no. Pero dense cuenta que cuando pasemos al bloque else el parámetro que se va a enviar va a ser (2 – 1) y eso es igual a 1. Como ven, este es el número que se va a enviar a la función.\r\n \r\n \r\n¿1 es igual a 1? Por supuesto que sí. Entonces la función retorna el valor de 1.\r\n \r\nEl proceso que acabamos de describir es el siguiente:\r\n \r\nreturn 4 * factorial(3);\r\nreturn 3 * factorial(2);\r\nreturn 2 * factorial(1);\r\n \r\nY ahora véanlo así, ¿cuánto es el factorial de 1? Pues 1, así que ya habremos resuelto uno de los casos, con eso, podemos resolver el resto.\r\n \r\nreturn 2 * factorial(1) = 2 * 1 = 2\r\n \r\nAhora ya sabemos cuánto es el factorial de 2, con esto podemos saber cuánto es el factorial de 3.\r\n \r\nreturn 3 * factorial(2) = 3 * 2 = 6\r\n \r\nY hemos dado la solución al factorial de 3, que era lo que necesitábamos para saber cuál era el factorial de 4.\r\n \r\nreturn 4 * factorial(3) = 4 * 6 = 24\r\n \r\nY listo, habremos obtenido el resultado. Esto es una función recursiva y es así como funciona.\r\n \r\n', NULL),
(63, 5, '5.14', 'Ejemplo sobre cómo utilizar la recursividad: Serie de Fibonacci\r\n', 'Que es un algoritmo de Iteración\r\nTambién es un técnica utilizada en programación que se basa en la repetición de ciclos, funcionales 100% en tareas repetitivas como recorrer un arreglo de datos, una lista, etc…\r\ndouble FibonacciA1(int n);\r\ndouble performancecounter_diff(LARGE_INTEGER *a, LARGE_INTEGER *b);\r\n \r\nmain(){\r\n   int n;\r\n   double b;\r\n   LARGE_INTEGER t_ini, t_fin;\r\n   double secs;\r\n   printf(\"\\t\\t n | FIB(n) | [ms] \\n\");\r\n   printf(\"\\t\\t-----+---------------+------\\n\");\r\n   for(n=0;n<=100;n++){\r\n      printf(\"\\t\\t%3d | \",n);\r\n      QueryPerformanceCounter(&t_ini);\r\n      b=FibonacciA1(n);\r\n      QueryPerformanceCounter(&t_fin);\r\n      secs = performancecounter_diff(&t_fin, &t_ini);\r\n      printf(\"%20.f | %.6g\\n\",b,secs*1000);\r\n   }\r\n   system(\"PAUSE\");\r\n}\r\n \r\ndouble FibonacciA1(int n){\r\n    if((n==0)||(n==1))\r\n        return (1);     \r\n    else\r\n        return(FibonacciA1(n-1)+FibonacciA1(n-2));\r\n}\r\n \r\ndouble performancecounter_diff(LARGE_INTEGER *a, LARGE_INTEGER *b)\r\n{\r\n  LARGE_INTEGER freq;\r\n  QueryPerformanceFrequency(&freq);\r\n  return (double)(a->QuadPart - b->QuadPart) / (double)freq.QuadPart;\r\n}\r\n', NULL),
(64, 5, '5.15', 'Recursividad versus iteración\r\n', 'Diferencia entre iteración y recursividad\r\nUn algoritmo recursivo es un algoritmo que expresa la solución de un problema en términos de una llamada a sí mismo. La llamada a sí mismo se conoce como llamada recursiva o recurrente.\r\nIteración es la repetición de una serie de instrucciones en un programa de computadora.\r\nComplejidad(Si ha de obtenerse el n-ésimo)\r\nRecursivo: complejidad exponencial O(c^n)\r\nIterativo: complejidad lineal: O(n)\r\n', NULL),
(65, 6, '6.02', 'Arreglos\r\n', 'Arreglos \r\n \r\nLos arreglos son estructuras de datos consistentes en un conjunto de datos del mismo tipo. Los arreglos tienen un tamaño que es la cantidad de objetos del mismo tipo que pueden almacenar. Los arreglos son entidades estáticas debido a que se declaran de un cierto tamaño y conservan este todo a lo largo de la ejecución del programa en el cual fue declarado.\r\n', NULL),
(66, 6, '6.03', 'Declaración de arreglos', 'Declaración de un vector o array\r\nLa sintaxis es:\r\ntipo nombreDeLaVariable[longitudDelArreglo];\r\nPor ejemplo, para declarar un array de 3 enteros usamos esto:\r\nint numeros[3];\r\nPara uno de 5 elementos de tipo double esto:\r\ndouble calificaciones[5];\r\nDeclaración y llenado de un array\r\nEn los ejemplos de arriba declaramos los arreglos pero no les pusimos datos iniciales, sólo dijimos cuánto medirán. Para poner datos iniciales la sintaxis es:\r\ntipo nombreDeLaVariable[longitud] = {elemento1, elemento2,…};\r\nAquí tenemos un array de 3 números enteros, inicializado al inicio:\r\n \r\nint numeros[3] = {80, 50, 200};\r\nTambién puede ser de tipo doble:\r\ndouble calificaciones[5] = {80.5, 90, 50.95, 99.7, 97.5};\r\nPor otro lado, podemos dejar que el compilador infiera la longitud del vector si nosotros lo inicializamos:\r\nchar nombre[ ] = {\'L\', \'u\', \'i\', \'s\'};\r\nEn este caso la longitud es de 4, pero no tuvimos que decirla porque el compilador la inferirá. Y no afectará al rendimiento de nuestro programa.\r\nModificar el valor de un arreglo\r\nPodemos cambiar el valor que tiene un valor dentro de un array. Recordemos que los vectores comienzan en 0. Si tenemos este arreglo:\r\nchar nombre[ ] = {\'L\', \'u\', \'i\', \'s\'};\r\nY hacemos lo siguiente:\r\nnombre[3] = \'z\';\r\nEl contenido será “Luiz” en lugar de “Luis”\r\nLeer un array\r\nPodemos acceder a un array igualmente a través de su índice. Por ejemplo, si tenemos este arreglo:\r\nint numeros[3] = {80, 50, 200};\r\nY queremos asignar una variable a la posición 2 (la que tiene el número 200) podemos hacer esto\r\nint miNumero = numeros[2];\r\nAhora miNumero tendrá el valor de 200\r\nRecorrer un arreglo\r\nPara recorrer un arreglo usamos un ciclo que va desde 0 hasta la longitud de nuestro arreglo. Por ejemplo, el siguiente código imprime el valor y el índice de un arreglo:\r\n#include <stdio.h>\r\n \r\nint main(int argc, char const *argv[])\r\n{\r\n	char nombre[] = {\'L\', \'u\', \'i\', \'s\'};\r\n	// En este caso, 4 es lo que mide nuestro arreglo pero\r\n	// el mayor índice es el 3, así que siempre irá desde\r\n	// 0 hasta 3 (ya que al llegar a 4 no se cumple la condición de < 4)\r\n	for (int i = 0; i < 4; ++i)\r\n	{\r\n		printf(\"Estamos en el índice %d y el valor es %c\\n\", i, nombre[i]);\r\n	}\r\n	return 0;\r\n}\r\nDeclaración de array bidimensional o de dos dimensiones\r\nAnteriormente vimos los arreglos como una lista simple, pero también podemos tener arreglos de dos dimensiones.\r\nVeamos este ejemplo que especifica un arreglo que representa un teclado matricial:\r\n/*\r\n	Es obligatorio declarar el tamaño de todas las dimensiones\r\n	excepto de la primera, pero de todos modos también la declaramos\r\n	para dejar claro el ejemplo\r\n*/\r\nchar teclado[4][4] = {\r\n	{\'1\', \'2\', \'3\', \'A\'},\r\n	{\'4\', \'5\', \'6\', \'B\'},\r\n	{\'7\', \'8\', \'9\', \'C\'},\r\n	{\'*\', \'0\', \'#\', \'D\'},\r\n};\r\nComo dice el código: debemos declarar el tamaño de todas las dimensiones, pero podemos dejar la primera vacía. Esto quiere decir que este código es válido:\r\nchar teclado[][4] = {\r\n	{\'1\', \'2\', \'3\', \'A\'},\r\n	{\'4\', \'5\', \'6\', \'B\'},\r\n	{\'7\', \'8\', \'9\', \'C\'},\r\n	{\'*\', \'0\', \'#\', \'D\'},\r\n};\r\nYa que estamos dejando que el compilador adivine la longitud de la segunda dimensión, cosa que no es válida. Si intentamos compilar de todos modos, saldrá este error:\r\nLeer array de dos dimensiones\r\nCon el ejemplo del arreglo de arriba vamos a ver este código para recorrerlo.\r\nEn este caso recorremos tanto en X como en Y. Podemos imaginar el arreglo como una tabla. Para acceder a él, usamos lo siguiente:\r\narreglo[x][y]\r\nAquí el código:\r\n \r\n#include <stdio.h>\r\n \r\nint main(int argc, char const *argv[])\r\n{\r\n	// Notar los dos grupos de corchetes [][]\r\n \r\n	// Nuestro arreglo mide 4 x 4\r\n \r\n	/*\r\n		Es obligatorio declarar el tamaño de la dimensión de todas las dimensiones\r\n		excepto de la primera, pero de todos modos también la declaramos\r\n		para dejar claro el ejemplo\r\n	*/\r\n	char teclado[4][4] = {\r\n		{\'1\', \'2\', \'3\', \'A\'},\r\n		{\'4\', \'5\', \'6\', \'B\'},\r\n		{\'7\', \'8\', \'9\', \'C\'},\r\n		{\'*\', \'0\', \'#\', \'D\'},\r\n	};\r\n \r\n	// Un ciclo para leer las filas del arreglo\r\n	for (int indiceFila = 0; indiceFila < 4; ++indiceFila)\r\n	{\r\n		printf(\"--Fila %d\\n\", indiceFila );\r\n		// Dentro del ciclo, ponemos otro ciclo para leer cada celda de la fila\r\n		for (int indiceCelda = 0; indiceCelda < 4; ++indiceCelda)\r\n		{\r\n			printf(\"Estamos en [%d]x[%d] y el valor es %c\\n\", indiceFila, indiceCelda, teclado[indiceFila][indiceCelda]);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\nCreamos 2 ciclos; uno dentro del otro. Para abstraerlo mejor, al primer índice lo tomamos como el índice de la fila. Y al segundo índice lo tomamos como el índice de la celda\r\n \r\n \r\n \r\n \r\n', NULL),
(68, 6, '6.04', 'Ejemplos de arreglos', 'EJEMPLO\r\n	\r\n	/* Declaración de un array. */\r\n \r\n	#include \r\n \r\n	main() /* Rellenamos del 0 - 9 */\r\n	{\r\n		int vector[10],i;\r\n		for (i=0;i<10;i++) vector[i]=i;\r\n		for (i=0;i<10;i++) printf(\" %d\",vector[i]);\r\n	}\r\nEJEMPLOS\r\nint vector[]={1,2,3,4,5,6,7,8};\r\nchar vector[]=\"programador\";\r\nchar vector[]={\'p\',\'r\',\'o\',\'g\',\'r\',\'a\',\'m\',\'a\',\'d\',\'o\',\'r\'};\r\nUna particularidad con los vectores de tipo char (cadena de caracteres), es que deberemos indicar en que elemento se encuentra el fin de la cadena mediante el caracter nulo (\\0). Esto no lo controla el compilador, y tendremos que ser nosotros los que insertemos este caracter al final de la cadena.\r\nPor tanto, en un vector de 10 elementos de tipo char podremos rellenar un máximo de 9, es decir, hasta vector[8]. Si sólo rellenamos los 5 primeros, hasta vector[4], debemos asignar el caracter nulo a vector[5]. Es muy sencillo: vector[5]=\'\\0\';\r\nAhora veremos un ejemplo de como se rellena un vector de tipo char.\r\nEJEMPLO\r\n \r\n	/* Vector de tipo char. */\r\n \r\n	#include \r\n \r\n	main() /* Rellenamos un vector char */\r\n	{\r\n		char cadena[20];\r\n		int i;\r\n		for (i=0;i<19 && cadena[i-1]!=13;i++)\r\n			cadena[i]=getche( );\r\n		if (i==19) cadena[i]=\'\\0\';\r\n		else cadena[i-1]=\'\\0\';\r\n		printf(\"\\n%s\",cadena);\r\n	}\r\n \r\n \r\nPodemos ver que en el for se encuentran dos condiciones:\r\nQue no se hayan rellenado todos los elementos (i<19)\r\nQue el usuario no haya pulsado la tecla ENTER, cuyo código ASCII es 13. (cadena[x-i]!=13)\r\nTambién podemos observar una nueva función llamada getche( ), que se encuentra en conio.h. Esta función permite la entrada de un caracter por teclado. Después se encuentra un if, que comprueba si se ha rellenado todo el vector. Si es cierto, coloca el caracter nulo en el elemento nº20 (cadena[19]). En caso contrario tenemos el else, que asigna el caracter nulo al elemento que almacenó el caracter ENTER.\r\n', NULL);
INSERT INTO `indices` (`id_indices`, `id_capitulo`, `numero_ind`, `nombre_ind`, `descripcion_ind`, `indice_id`) VALUES
(69, 6, '6.05', 'Cómo pasar arreglos a funciones', 'Un array puede ser pasado como argumento a una función, permitiendo por consiguiente que el array completo sea pasado a la función. Pero en cambio, la manera en que se pasa una variable ordinaria a una función es muy distinta a la forma en como se pasa un array.\r\nPara pasar un array a una función, el nombre del array debe aparacer sólo, sin corchetes ni índices, como un argumento actual dentro de la llamada a la función. El correspondiente argumento formal se escribe de la misma manera, pero debe ser declarado como un array dentro de la declaración de argumentos formales.\r\nCuando se declara un array unidimensional como un argumento formal, el array se escribe con un par de corchetes cuadrados vacios. El tamaño del array no se especifica dentro de la especificación formal de argumentos.\r\nSe precisa tener algún cuidado cuando se escriben declaraciones de funciones que incluyen especificaciones de tipos de argumentos. Si alguno de los argumentos es un array, el tipo de datos de cada array debe estar seguido por un par de corchetes, indicando así que el argumento es un array. En el caso de prototipos de funciones, un par de corchetes vacios debe seguir al nombre de cada argumento array.\r\nSimilarmente, si la primera línea de una definición de función incluye declaraciones formales de argumentos, cada nombre de array que aparezca como un argumento formal debe estar seguido por un par de argumentos vacíos.\r\nCuando un array se pasa como argumento de una función, los valores de los elementos del array no son pasados a la función , sino que el nombre del array se interpreta como una dirección del primer elemento del array, la dirección de memoria conteniendo el primer elemento del array. Esta dirección se asigna al correspondiente argumento formal cuando se llama a la función. El argumento formal se convierte por tanto en un puntero al primer elemento del array.\r\nLos argumentos pasados de esta manera se dice que son pasados por referencia en vez de por valor.\r\nCuando se hace una referencia a un elemento del array dentro de la función , el índice del elemento se añade al valor del puntero para indicar la dirección del elemento especificado. Por tanto, cualquier elemento del array puede ser accedido dentro de la función.\r\nAdemás, si un elemento del array es alterado dentro de la función, esta alteración será reconocida en la porción del programa desde la que ha sido llamada (en realidad, en todo el ámbito de la definición del array).\r\nEl hecho de que un array pueda ser modificado globalmente dentro de una función proporciona un mecanismo adecuado para mover multiples datos de o desde una función a la porción llamante del programa. Simplemente se pasa el array a la función y se alteran sus elementos dentro de ella. O, si el array debe ser preservado, se copia el array (elemento por elemento) dentro de la porción llamante del programa, se pasa la copia a la función y se realizan las alteraciones.\r\nEl programador debe tener cierto cuidado al alterar un array dentro de una función ya que es muy fácil alterarlo de forma no intencionada fuera de la función.\r\n', NULL),
(70, 6, '6.01', 'Introducción', 'Un programa C va a estar compuesto de una o más funciones repartidas en uno o más\r\nmódulos de código. Como ya se vio, en un programa en C al menos siempre existirá una\r\nfunción main que será el punto de entrada al programa.\r\n', NULL),
(71, 6, '6.06', 'Ordenamiento de arreglos\r\n', 'Para ordenar arrays tenemos a nuestra disposición diferentes tipos de algoritmos para hacerlo. Hay lo que se llaman formas naturales de ordenación y las que no lo son. El método de la burbuja es un método de ordenación no natural para ordenar arrays. Consiste en ir recorriendo todo el array a ordenar, comparando dos elementos al mismo tiempo e intercambiándolos si no están en el lugar apropiado. Al finalizar el recorrido por todos los elementos, se determina si hubo algún cambio, y en caso afirmativo, se repite el algoritmo hasta que no haya cambio alguno.\r\n\r\nDe todas formas si quieres profundizar en el tema de algoritmos de ordenación, puedes visitar los apuntes (de mi universidad) que tengo subidos sobre ello.\r\n\r\nEl nombre que se le atribuye viene porque al hacer el intercambio, los elementos más pequeños “burbujean” de forma progresiva hasta el inicio del array, mientras que los más grandes se “hunden”. Es el algoritmo de ordenación por comparación más sencillo de implementar.\r\n\r\nEn cuanto al rendimiento, el algoritmo no destaca por su rapidez.  Es de los más pobres en rendimiento y sobre todo no es recomendable usarlo en arrays largos. Sin embargo, está bastante bien si estás empezando ya que se caracteriza por su sencillez.\r\n\r\nEn concreto el ejemplo que voy a mostrar a continuación es el código para ordenar un array de mayor a menor, sin embargo para ordenador de menor a mayor solo habría que cambiar uno de los signos que comento en el código.\r\n\r\n#include <iostream> \r\nusing namespace std;\r\n#include <cstdlib>\r\n\r\nint const DIM = 10;\r\ntypedef float tArray[DIM];\r\n\r\nvoid rellenarArray(tArray);\r\nvoid ordenarArray(tArray);\r\nvoid mostrarArray(const tArray);\r\n\r\nint main(){\r\n	tArray miArray;\r\n	\r\n	rellenarArray(miArray);\r\n	ordenarArray(miArray);\r\n	mostrarArray(miArray);\r\n	\r\n	system(\"PAUSE\");\r\n	return 0;\r\n}\r\n\r\nvoid rellenarArray(tArray miArray){\r\n	cout << \"Introduzca los 10 elementos del array\" << endl;\r\n	\r\n	for (int i = 0; i < DIM; i++){ // Rellenamos las 10 posiciones del array\r\n		cin >> miArray[i];\r\n	}\r\n}\r\n\r\nvoid ordenarArray(tArray miArray){\r\n	float temporal;\r\n	\r\n	for (int i = 0;i < DIM; i++){\r\n		for (int j = 0; j< DIM-1; j++){\r\n			if (miArray[j] < miArray[j+1]){ // Ordena el array de mayor a menor, cambiar el \"<\" a \">\" para ordenar de menor a mayor\r\n			temporal = miArray[j]; \r\n			miArray[j] = miArray[j+1]; \r\n			miArray[j+1] = temporal;\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nvoid mostrarArray(const tArray miArray){\r\n	cout << \"Mostrando array ordenado...\" << endl;\r\n	\r\n	for (int i = 0; i < DIM; i++) // Imprime las 10 posiciones\r\n		cout << miArray[i] << endl;\r\n}	', NULL),
(72, 6, '6.07', 'Cálculo de la media, la mediana y la moda a través de arreglos', '/*Programa que lee un vector de numeros ordenados de forma creciente*/\r\n/*Calcula la media, la mediana y la moda*/\r\n/*Incluye las funciones media, mediana y moda*/\r\n#include <stdio.h>\r\n\r\n/*Maximo tamaño del vector: 100*/\r\n#define MAXNUM 100\r\n\r\n/*Funcion que calcula la media aritmetica*/\r\nfloat media(int lon, float v[MAXNUM])\r\n{\r\n	int i;\r\n	float media=0;\r\n\r\n	for(i=0;i<lon; i++)\r\n		media+=v[i];\r\n	\r\n	media/=lon;\r\n	return(media);\r\n}\r\n\r\n/*Funcion que encuentra la mediana*/\r\nfloat mediana(int lon, float v[MAXNUM])\r\n{\r\n	if (lon%2)\r\n		return(v[lon/2]);\r\n	\r\n	else\r\n		return((v[(lon/2)-1]+v[lon/2])/2);\r\n}\r\n\r\n/*Funcion que encuentra la moda y devuelve por referencia su frecuencia*/		\r\nfloat moda(int lon, float v[MAXNUM], int *frecuencia)\r\n{\r\n	int i=0, cont=1;\r\n	float moda;\r\n\r\n	moda=v[i];\r\n\r\n	while(i<lon)\r\n	{\r\n		/*Si se repite el numero*/\r\n		if(v[i]==v[i+1])\r\n		{\r\n			cont++;\r\n			i++;\r\n		}\r\n\r\n		else\r\n		{\r\n			if(cont>(*frecuencia))\r\n			{\r\n				moda=v[i];\r\n				*frecuencia=cont;\r\n				cont=1;\r\n				i++;\r\n			}\r\n			\r\n			else\r\n			{\r\n				cont=1;\r\n				i++;\r\n			}\r\n		}\r\n	}\r\n	return(moda);\r\n}\r\n\r\nvoid main()\r\n{\r\n	int i, n, frec=1;\r\n	float vector[MAXNUM];\r\n\r\n	/*Introduce los datos*/\r\n	printf(\"\\nIntroduzca la longitud del vector:\\n\");\r\n	scanf(\"%d%*c\", &n);\r\n	\r\n	printf(\"\\nIntroduzca los numeros ordenados de menor a mayor:\\n\");\r\n	for(i=0;i<n;i++)\r\n		scanf(\"%f%*c\", &vector[i]);\r\n	\r\n	\r\n	\r\n	printf(\"\\nMedia: %f\\n\",media(n,vector));\r\n	printf(\"\\nMediana: %f\\n\", mediana(n,vector));\r\n	printf(\"\\nModa: %f\",moda(n,vector,&frec));\r\n	printf(\"\\nAparece %d veces\\n\",frec);\r\n}', NULL),
(73, 6, '6.08', 'Búsqueda en arreglos\r\n', 'Mediante programación en C++, hacer un programa que busque un elemento mediante una búsqueda secuencial.\r\n\r\n#include<iostream.h>\r\n#include<conio.h>\r\n#define MAX 50\r\nvoid leerarray(int,int[]);\r\nint buscasecuencial(int,int[],int);\r\nvoid main()\r\n{\r\nint x[MAX],elem,n;\r\ncout<<\"Ingrese limite del arreglo\";\r\ncin>>n;\r\nleerarray(n,x);\r\ncout<<\"Ingrese elemento a buscar \";\r\ncin>>elem;\r\nif(buscasecuencial(n,x,elem)==1)\r\ncout<<\"Elemento encontrado \";\r\nelse\r\ncout<<\"Elemento no encontrado \";\r\ngetch();\r\n}\r\nvoid leerarray(int n,int a[])\r\n{ for(int i=0;i<n;i++)\r\n{\r\ncout<<\"Ingrese elemento \"<<i<<\":\";\r\ncin>>a[i];\r\n}\r\n}\r\nint buscasecuencial(int n,int a[],int ele)\r\n{\r\nfor(int i=0;i<n;i++)\r\nif(ele==a[i])return 1;\r\nreturn 0;\r\n}\r\n', NULL),
(74, 6, '6.09', 'Arreglos con múltiples subíndices\r\n\r\n', 'Arreglos con múltiple subíndices\r\nEs la representación de tablas de valores, consistiendo de información arreglada en renglones y columnas. Para identificar un elemento particular de la tabla, deberemos de especificar dos subíndices; el primero identifica el renglón del elemento y el segundo identifica la columna del elemento. A los arreglos que requieren dos subíndices para identificar un elemento en particular se conocen como arreglo de doble subíndice. Note que los arreglos de múltiples subíndices pueden tener más de dos subíndices. El estándar ANSI indica que un sistema ANSI C debe soportar por lo menos 12 subíndices de arreglo.', NULL),
(75, 7, '7.01', 'Introducción\r\n', 'Los apuntadores en C y C++ son una herramienta muy potente de programaci´on que suele causar mucha\r\nconfusi´on en los estudiantes que la est´an aprendiendo. Adem´as, cuando los programadores cometen un error\r\nen su utilizaci´on, puede ser muy dif´ıcil encontrar el error, por lo cual es importante saber utilizarlos muy\r\nbien. El uso de apuntadores en C y C++ es muy importante debido a que permite hacer los programas m´as\r\neficientes y m´as flexibles. En en este art´ıculo se explica de una manera sencilla y breve todo lo referente a la\r\nutilizaci´on de apuntadores tanto en C como en C++.\r\nTodo lo explicado en este art´ıculo aplica tanto para C como para C++, a menos que se especifique un\r\nlenguaje en particular. En algunos ejemplos de c´odigo que son aplicables a C aparecen instrucciones de\r\nentrada y salida de las librer´ıas est´andar de C++\r\n', NULL),
(76, 7, '7.02', 'Definición e inicialización de variables de apuntador\r\n', 'Cuando se declara una variable, el compilador reserva un espacio de memoria para ella y asocia el nombre\r\nde ´esta a la direcci´on de memoria desde donde comienzan los datos de esa variable. Las direcciones de memoria\r\nse suelen describir como n´umeros en hexadecimal.\r\nUn apuntador es una variable cuyo valor es la direcci´on de memoria de otra variable. Se dice que un\r\napuntador “apunta” a la variable cuyo valor se almacena a partir de la direcci´on de memoria que contiene el\r\napuntador. Por ejemplo, si un apuntador p almacena la direcci´on de una variable x, se dice que “p apunta a\r\nx”.\r\n', NULL),
(77, 7, '7.03', 'Operadores para apuntadores', 'Operador Address-of &\r\nEl operador unario & devuelve la dirección de su operando:\r\nunsafe\r\n{\r\n    int number = 27;\r\n    int* pointerToNumber = &number;\r\n\r\n    Console.WriteLine($\"Value of the variable: {number}\");\r\n    Console.WriteLine($\"Address of the variable: {(long)pointerToNumber:X}\");\r\n}\r\n// Output is similar to:\r\n// Value of the variable: 27\r\n// Address of the variable: 6C1457DBD4\r\n\r\nEl operando del operador & debe ser una variable fija. Las variables fijas son las que residen en ubicaciones de almacenamiento que no se ven afectadas por el funcionamiento del recolector de elementos no utilizados. En el ejemplo anterior, la variable local number es una variable fija, ya que reside en la pila. Las variables que residen en ubicaciones de almacenamiento que pueden verse afectadas por el recolector de elementos no utilizados (por ejemplo, reubicadas) se denominan variables móviles. Los campos de objeto y los elementos de matriz son ejemplos de variables móviles. Puede obtener la dirección de una variable móvil si la \"fija\" o \"ancla\" con una instrucción fixed. La dirección obtenida solo es válida dentro del bloque de una instrucción fixed. En el ejemplo siguiente se muestra cómo usar una instrucción fixed y el operador &:\r\n\r\nunsafe\r\n{\r\n    byte[] bytes = { 1, 2, 3 };\r\n    fixed (byte* pointerToFirst = &bytes[0])\r\n    {\r\n        // The address stored in pointerToFirst\r\n        // is valid only inside this fixed statement block.\r\n    }\r\n}\r\n\r\nNo se puede obtener la dirección de una constante o un valor.\r\nPara obtener más información sobre las variables fijas y móviles, vea la sección Variables fijas y móviles de Especificación del lenguaje C#.\r\nEl operador binario & calcula el AND lógico de sus operandos booleanos o el AND lógico bit a bit de sus operandos enteros.\r\nOperador de direccionamiento indirecto del puntero *\r\nEl operador unario de direccionamiento indirecto del puntero * obtiene la variable a la que apunta su operando. También se conoce como operador de desreferencia. El operando del operador * debe ser un tipo de puntero.\r\n\r\nunsafe\r\n{\r\n    char letter = \'A\';\r\n    char* pointerToLetter = &letter;\r\n    Console.WriteLine($\"Value of the `letter` variable: {letter}\");\r\n    Console.WriteLine($\"Address of the `letter` variable: {(long)pointerToLetter:X}\");\r\n\r\n    *pointerToLetter = \'Z\';\r\n    Console.WriteLine($\"Value of the `letter` variable after update: {letter}\");\r\n}\r\n// Output is similar to:\r\n// Value of the `letter` variable: A\r\n// Address of the `letter` variable: DCB977DDF4\r\n// Value of the `letter` variable after update: Z\r\n\r\nNo se puede aplicar el operador * a una expresión de tipo void*.\r\nEl operador binario * calcula la multiplicación de sus operandos numéricos.\r\nOperador de acceso a miembros de puntero ->\r\nEl operador -> combina el direccionamiento indirecto del puntero y el acceso a miembros. Es decir, si x es un puntero de tipo T* y y es un miembro accesible de tipo T, una expresión con el formato\r\n\r\nx->y\r\n\r\n(*x).y\r\n\r\npublic struct Coords\r\n{\r\n    public int X;\r\n    public int Y;\r\n    public override string ToString() => $\"({X}, {Y})\";\r\n}\r\n\r\npublic class PointerMemberAccessExample\r\n{\r\n    public static unsafe void Main()\r\n    {\r\n        Coords coords;\r\n        Coords* p = &coords;\r\n        p->X = 3;\r\n        p->Y = 4;\r\n        Console.WriteLine(p->ToString());  // output: (3, 4)\r\n    }\r\n}\r\n\r\nNo se puede aplicar el operador -> a una expresión de tipo void*.\r\nOperador de acceso de elemento de puntero []\r\nEn el caso de una expresión p de un tipo de puntero, un acceso de elemento de puntero con el formato p[n] se evalúa como *(p + n), donde n debe ser de un tipo convertible de forma implícita en int, uint, long o ulong. Para obtener información sobre el comportamiento del operador + con punteros, vea la sección Suma o resta de un valor entero en un puntero.\r\nEn el ejemplo siguiente se muestra cómo acceder a los elementos de matriz con un puntero y el operador []:\r\n\r\nunsafe\r\n{\r\n    char* pointerToChars = stackalloc char[123];\r\n\r\n    for (int i = 65; i < 123; i++)\r\n    {\r\n        pointerToChars[i] = (char)i;\r\n    }\r\n\r\n    Console.Write(\"Uppercase letters: \");\r\n    for (int i = 65; i < 91; i++)\r\n    {\r\n        Console.Write(pointerToChars[i]);\r\n    }\r\n}\r\n// Output:\r\n// Uppercase letters: ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n\r\nEn el ejemplo anterior, una expresión stackalloc asigna un bloque de memoria en la pila.\r\n Nota\r\n\r\nEl operador de acceso de elemento de puntero no busca errores fuera de límites.\r\nNo puede usar [] para el acceso de elemento de puntero con una expresión de tipo void*.\r\nTambién puede usar el operador [] para acceso de elemento de matriz o indizador.\r\n\r\nOperadores aritméticos de puntero\r\nPuede realizar las siguientes operaciones aritméticas con punteros:\r\nAgregar o restar un valor entero en un puntero\r\nRestar dos punteros\r\nIncrementar o reducir un puntero\r\nNo es posible realizar esas operaciones con punteros de tipo void*.\r\nPara obtener información sobre las operaciones aritméticas admitidas con tipos numéricos, vea Operadores aritméticos.\r\nSuma o resta de un valor entero en un puntero\r\nEn el caso de un puntero p de tipo T* y una expresión n de un tipo convertible de forma implícita en int, uint, long o ulong, la suma y la resta se definen de este modo:\r\nAmbas expresiones p + n y n + p generan un puntero de tipo T* que resulta de agregar n * sizeof(T) a la dirección proporcionada por p.\r\nLa expresión p - n genera un puntero de tipo T* que resulta de restar n * sizeof(T) a la dirección proporcionada por p.\r\nEl operador sizeof obtiene el tamaño de un tipo en bytes.\r\nEn el siguiente ejemplo se muestra el uso del operador + con un puntero:\r\n\r\nunsafe\r\n{\r\n    const int Count = 3;\r\n    int[] numbers = new int[Count] { 10, 20, 30 };\r\n    fixed (int* pointerToFirst = &numbers[0])\r\n    {\r\n        int* pointerToLast = pointerToFirst + (Count - 1);\r\n\r\n        Console.WriteLine($\"Value {*pointerToFirst} at address {(long)pointerToFirst}\");\r\n        Console.WriteLine($\"Value {*pointerToLast} at address {(long)pointerToLast}\");\r\n    }\r\n}\r\n// Output is similar to:\r\n// Value 10 at address 1818345918136\r\n// Value 30 at address 1818345918144\r\n\r\nResta de puntero\r\nEn el caso de dos punteros p1 y p2 de tipo T*, la expresión p1 - p2 genera la diferencia entre las direcciones proporcionadas por p1 y p2 dividida por sizeof(T). El tipo del resultado es long. Es decir, p1 - p2 se calcula como ((long)(p1) - (long)(p2)) / sizeof(T).\r\nEl ejemplo siguiente muestra la resta de puntero:\r\n\r\nunsafe\r\n{\r\n    int* numbers = stackalloc int[] { 0, 1, 2, 3, 4, 5 };\r\n    int* p1 = &numbers[1];\r\n    int* p2 = &numbers[5];\r\n    Console.WriteLine(p2 - p1);  // output: 4\r\n}\r\n\r\nIncremento y decremento de puntero\r\nEl operador de incremento ++agrega 1 a su operando de puntero. El operador de decremento --resta 1 a su operando de puntero.\r\nAmbos operadores se admiten con dos formatos: postfijo (p++ y p--) y prefijo (++p y --p). El resultado de p++ y p-- es el valor de p antes de la operación. El resultado de ++p y --p es el valor de p después de la operación.\r\nEl ejemplo siguiente muestra el comportamiento de los operadores de incremento postfijo y prefijo:\r\n\r\nunsafe\r\n{\r\n    int* numbers = stackalloc int[] { 0, 1, 2 };\r\n    int* p1 = &numbers[0];\r\n    int* p2 = p1;\r\n    Console.WriteLine($\"Before operation: p1 - {(long)p1}, p2 - {(long)p2}\");\r\n    Console.WriteLine($\"Postfix increment of p1: {(long)(p1++)}\");\r\n    Console.WriteLine($\"Prefix increment of p2: {(long)(++p2)}\");\r\n    Console.WriteLine($\"After operation: p1 - {(long)p1}, p2 - {(long)p2}\");\r\n}\r\n// Output is similar to\r\n// Before operation: p1 - 816489946512, p2 - 816489946512\r\n// Postfix increment of p1: 816489946512\r\n// Prefix increment of p2: 816489946516\r\n// After operation: p1 - 816489946516, p2 - 816489946516\r\n\r\nOperadores de comparación de puntero\r\nPuede usar los operadores ==, !=, <, >, <= y >= para comparar los operandos de cualquier tipo de puntero, incluido void*. Esos operadores comparan las direcciones proporcionadas por los dos operandos como si fueran enteros sin signo.\r\nPara obtener información sobre el comportamiento de esos operadores para operandos de otros tipos, vea los artículos Operadores de igualdad y Operadores de comparación.\r\nPrioridad de operadores\r\nEn la lista siguiente se ordenan los operadores relacionados con el puntero desde la prioridad más alta a la más baja:\r\nOperadores de incremento x++ y decremento x-- postfijos y operadores -> y []\r\nOperadores de incremento ++x y decremento --x prefijos y operadores & y *\r\nOperadores + y - de suma\r\nOperadores de comparación <, >, <= y >=\r\nOperadores de igualdad == y !=\r\nUse paréntesis, (), para cambiar el orden de evaluación impuesto por la prioridad de los operadores.\r\nPara obtener la lista completa de los operadores de C# ordenados por nivel de prioridad, vea la sección Prioridad de operadores del artículo Operadores de C#.\r\nPosibilidad de sobrecarga del operador\r\nUn tipo definido por el usuario no puede sobrecargar los operadores relacionados con el puntero &, *, -> y [].', NULL),
(78, 7, '7.04', 'Llamada a funciones por referencia\r\n', 'Llamada por valor\r\nYa conocemos las funciones en las que llamamos por valor. Cabe mencionar que esto sólo aplica a las funciones que reciben argumentos.\r\n\r\n\r\n \r\nEn esas funciones, una copia de la variable es creada dentro de la llamada de la función, y no afecta a la original. Veamos este ejemplo de una función que incrementa un entero:\r\n\r\nint incrementar(int numero){\r\n	//Incrementar en 1\r\n	numero = numero + 1;\r\n}\r\n\r\nNo estamos devolviendo nada, estamos simplemente alterando a la variable que recibimos. Ahora lo llamamos así:\r\n\r\n#include<stdio.h>\r\n\r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint incrementar(int numero);\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero = 10;\r\n	printf(\"Antes de llamar a la funcion, numero es %d\\n\", numero);\r\n	incrementar(numero);\r\n	printf(\"Despues de llamar a la funcion, numero es %d\", numero);\r\n}\r\n\r\n// Ahora sí definimos la función con todo y cuerpo\r\nint incrementar(int numero){\r\n	//Incrementar en 1\r\n	numero = numero + 1;\r\n}\r\n\r\nLa salida del programa es:\r\n\r\nAntes de llamar a la funcion, numero es 10\r\nDespues de llamar a la funcion, numero es 10\r\n\r\nComo vemos, se crea una nueva variable dentro de la función. Y aunque afectemos a la misma, la variable original sigue intacta. Esto es a lo que referimos cuando pasamos variables por valor.\r\n\r\nLlamada por referencia\r\nUna llamada por referencia ocurre cuando no pasamos el nombre de la variable, sino su dirección. En este caso no se crea una nueva variable.\r\n\r\nModifiquemos la función para que ahora reciba el puntero o apuntador a una variable, no una variable en sí. Quedaría así:\r\n\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\n\r\nAhora recibiremos direcciones de variables. Y al incrementar, incrementamos el valor que haya en la dirección que dijimos.\r\n\r\nCorremos el programa con esto:\r\n\r\n#include<stdio.h>\r\n\r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint incrementar(int *numero);\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero = 10;\r\n	printf(\"Antes de llamar a la funcion, numero es %d\\n\", numero);\r\n\r\n	// Con el operador & obtenemos la dirección de numero\r\n	incrementar(&numero);\r\n	printf(\"Despues de llamar a la funcion, numero es %d\", numero);\r\n}\r\n\r\n// Ahora sí definimos la función con todo y cuerpo\r\n//Notar el * antes de numero\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\n\r\nLa salida del programa es:\r\n\r\nAntes de llamar a la funcion, numero es 10\r\nDespues de llamar a la funcion, numero es 10\r\n\r\n#include<stdio.h>\r\n\r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint incrementar(int *numero);\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero = 10;\r\n	printf(\"Antes de llamar a la funcion, numero es %d\\n\", numero);\r\n\r\n	// Con el operador & obtenemos la dirección de numero\r\n	incrementar(&numero);\r\n	printf(\"Despues de llamar a la funcion, numero es %d\", numero);\r\n}\r\n\r\n// Ahora sí definimos la función con todo y cuerpo\r\n//Notar el * antes de numero\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\n\r\nNotemos por favor el operador & que se encarga de obtener la dirección de memoria de una variable. Cuando ejecutamos el programa, la salida es:\r\n\r\nAntes de llamar a la funcion, numero es 10\r\nDespues de llamar a la funcion, numero es 11\r\n\r\n\r\n \r\nComo vemos, se crea una nueva variable dentro de la función. Y aunque afectemos a la misma, la variable original sigue intacta. Esto es a lo que referimos cuando pasamos variables por valor.\r\n\r\nLlamada por referencia\r\nUna llamada por referencia ocurre cuando no pasamos el nombre de la variable, sino su dirección. En este caso no se crea una nueva variable.\r\n\r\nModifiquemos la función para que ahora reciba el puntero o apuntador a una variable, no una variable en sí. Quedaría así:\r\n\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\nAhora recibiremos direcciones de variables. Y al incrementar, incrementamos el valor que haya en la dirección que dijimos.\r\n\r\nCorremos el programa con esto:\r\n#include<stdio.h>\r\n\r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint incrementar(int *numero);\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero = 10;\r\n	printf(\"Antes de llamar a la funcion, numero es %d\\n\", numero);\r\n\r\n	// Con el operador & obtenemos la dirección de numero\r\n	incrementar(&numero);\r\n	printf(\"Despues de llamar a la funcion, numero es %d\", numero);\r\n}\r\n\r\n// Ahora sí definimos la función con todo y cuerpo\r\n//Notar el * antes de numero\r\nint incrementar(int *numero){\r\n	//Incrementar en 1\r\n	(*numero) = (*numero) + 1;\r\n}\r\n\r\nNotemos por favor el operador & que se encarga de obtener la dirección de memoria de una variable. Cuando ejecutamos el programa, la salida es:\r\n\r\nAntes de llamar a la funcion, numero es 10\r\nDespues de llamar a la funcion, numero es 11\r\n\r\n\r\n \r\nComo vemos ahora sí se ha incrementado el número.\r\n\r\nUsos de las llamadas por referencia\r\nLas llamadas por referencia son más rápidas, ya que no creamos nuevos valores en la memoria.\r\n\r\nAparte del rendimiento, las funciones por referencia son usadas cuando queremos devolver dos variables; eso no es posible con una función normal, pero con una función por referencia sí lo es.\r\n\r\nVeamos el caso de una función (sin sentido, pero sirve para ejemplificar) que devuelve dos números enteros. No puede hacer un return, en cambio mejor recibe a ambos números y a cada uno de ellos le asigna un valor.\r\n\r\n#include<stdio.h>\r\n\r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint devolverEnteros(int *numero1, int *numero2);\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero1 = 0, numero2 = 0;\r\n	printf(\"Antes de llamar a la funcion, numero1 es %d y numero2 es %d\\n\", numero1, numero2);\r\n\r\n	// Con el operador & obtenemos la dirección de numero\r\n	devolverEnteros(&numero1, &numero2);\r\n	printf(\"Despues de llamar a la funcion, numero1 es %d y numero2 es %d\\n\", numero1, numero2);\r\n}\r\n\r\n// Ahora sí definimos la función con todo y cuerpo\r\n//Notar el * antes de numero\r\nint devolverEnteros(int *numero1, int *numero2){\r\n	(*numero1) = 10;\r\n	(*numero2) = 20;\r\n}\r\n\r\nCon la siguiente salida:\r\n\r\nAntes de llamar a la funcion, numero1 es 0 y numero2 es 0\r\nDespues de llamar a la funcion, numero1 es 10 y numero2 es 20\r\n\r\nPara intercambiar variables\r\nCuando queremos intercambiar una variable también hacemos uso de estas funciones.\r\n\r\nPor ejemplo, si tenemos a= 50 y b = 85 y queremos intercambiarlas de modo que a = 85 y b = 50 podemos hacer esto:\r\n#include<stdio.h>\r\n\r\n// Es una buena práctica definir el prototipo de las funciones aquí arriba\r\n// ojo: sólo el prototipo, no el cuerpo\r\nint intercambiarEnteros(int *numero1, int *numero2);\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int numero1 = 50, numero2 = 85;\r\n	printf(\"Antes de llamar a la funcion, numero1 es %d y numero2 es %d\\n\", numero1, numero2);\r\n\r\n	// Con el operador & obtenemos la dirección de las variables\r\n	intercambiarEnteros(&numero1, &numero2);\r\n	printf(\"Despues de llamar a la funcion, numero1 es %d y numero2 es %d\\n\", numero1, numero2);\r\n}\r\n\r\n// Ahora sí definimos la función con todo y cuerpo\r\nint intercambiarEnteros(int *numero1, int *numero2){\r\n	int temporal = (*numero1);\r\n	(*numero1) = (*numero2);\r\n	(*numero2) = temporal;\r\n}\r\n\r\nPrimero ambas variables tienen un valor, la primera 50 y la segunda 85. Llamamos a la función que se encarga de intercambiarlas y al final la primera será 85 y la segunda 50:\r\n\r\n\r\n \r\nIntercambio de variable: llamada por referencia en C\r\nIntercambio de variable: llamada por referencia en C\r\n\r\n¿Quién usa llamadas por referencia?\r\nEn la API de SQLite para C, para abrir una base de datos llamamos a la función sqlite3_open que recibe el nombre y un apuntador a una variable de tipo sqlite3.\r\n\r\nSi todo va bien, tendremos en la variable una referencia a la base de datos.\r\n\r\n', NULL),
(79, 7, '7.05', 'Uso del calificador const con apuntadores\r\n', 'A primera vista sorprende cuantas cosas pueden se constantes en C++. Se pueden declarar const\r\n\r\nvariables,\r\npunteros o las variables a que apuntan (doblemente const),\r\nreferencias,\r\nclases,\r\ninstancias de clases o\r\nsólo miembros de datos dentro de una clase y también\r\nmétodos de una clase.\r\nPara complicar la cosa aún más se puede usar const para sustituir enum y #define.\r\n\r\nVariables constantes\r\nUna variable declarada const no se puede cambiar, es decir, es una constante. No obstante, la palabra const sólo se tiene en cuenta durante el tiempo de compilación. El compilador emite un error cuando encuentra una instrucción que quiere asignar un valor a una constante, pero físicamente el valor de una constante puede estar guardado en la memoria RAM y cuesta poco asignar otro valor a esta posición mediante un uso malintencionado de punteros y casts.\r\n\r\nCuando un compilador optimiza el código ejecutable, entonces puede optar por no leer el valor de la memoria sino incrustarlo directamente en las instrucciones del procesador. Así es posible que el valor en la memoria RAM cambie pero el programa sigue con el valor que el compilador determinó durante la compilación. No obstante, la dirección de la constante sigue siendo válida aunque el ejecutable no lee de ahí.\r\n\r\nTener una representación física en la memoria es lo que distingue una variable declarada const de constantes definidas por enum o #define. Es decir, puedo hacer esto\r\n\r\nconst int c = 5;\r\nconst int* p = &c;  // p apunta a la dirección de c. *p vale 5.\r\npero no puede hacer esto\r\n\r\nenum { CONSTANTE_ENUM };\r\nconst enum* pe = &CONSTANTE_ENUM // Error de compilación\r\nEsto es porque una constante de enum sola no tiene tipo sino sólo representa un valor. Lo que convierte un enum en un tipo es el conjunto de los valores de que está formado.\r\n\r\nLa cosa es aún más complicada con los #define. Es una directiva del preprocesador que reemplaza un texto por otro antes de que el código llegue al compilador. Quiere decir, los nombres de las macros definido por #define no existen para el compilador.\r\n\r\n#define CONSTANTE 5\r\nint a = CONSTANTE;  // El compilador ve \"int a = 5\".\r\nPunteros\r\nLos punteros son variables que guardan una dirección de memoria. Como cualquier variable su valor puede ser constante o no. Los punteros son especiales por no tener sólo un tipo de qué son – una dirección de memoria – pero por tener también otro tipo asociado del valor a que apuntan. Y este valor puede ser constante o variable de forma independiente. Por este motivo puede haber dos const en la definición de un puntero.\r\n\r\n      int        variable = 1;\r\nconst int        constante = 2;\r\nconst int *      puntero_a_constante = &constante;\r\n      int *const puntero_constante_a_variable = &variable;\r\nconst int *const puntero_constante_a_constante = &constante;\r\nEl puntero_a_constante puede apuntar a varios objetos, pero no puede modificarlos. Cadenas de caracteres se definen típicamente así: como const char*.\r\nUn puntero_constante_a_variable puede modificar el objeto a que apunta, pero no puede apuntar a otra cosa.\r\nFinalmente, un puntero_constante_a_constante ni puede modificar el objeto a que apunta ni apuntar a otro objeto. Por este punto de vista una cadena de texto hardcoded tiene realmente el tipo const char *const. Sin embargo, se usa poco.\r\nComo nota quiero decir también que existe la notación\r\n\r\nint const* puntero\r\npero se usa menos. De hecho no conviene usarlo porque es más ambiguo: ¿el const se refiere al tipo (int) o a la dirección de memoria (el “*”)?\r\n\r\nReferencias\r\nPara las referencias valen básicamente las mismas reglas que para punteros. No obstante hay una importante diferencia: referencias no pueden referirse a otra instancia. Al contrario de punteros las referencias no pueden existir por si mismas sino deben inicializarse a la hora de ser declarada.\r\n\r\n      int        variable = 1;\r\nconst int        constante = 2;\r\nconst int &      referencia_a_constante = constante;\r\n \r\n// &const es permitido pero innecesario. Por eso nunca se usa.\r\n      int &const referencia_constante_a_variable = variable;\r\nconst int &const referencia_constante_a_constante = constante;\r\nComo las referencias apuntan al mismo objeto durante toda su vida, & y &const es lo mismo, y por eso nunca se escribe &const.\r\n\r\nEs fácil hacer un cast para convertir un puntero de un objeto a otro objeto con un tipo diferente. Las referencias, en cambio, tienen el mismo tipo que el objeto a que se refieren y aportan más seguridad contra un cast implícito.  Por eso es preferible usar referencias en lugar de punteros siempre cuando sea posible.\r\n\r\nMuy especialmente conviene usar referencias a constantes en lugar de constantes como parámetros de funciones. Se usan igual pero sólo requieren copiar un puntero en lugar de un objeto entero. Es decir, no se llamará un constructor para una referencia.\r\n\r\nClases constantes\r\nIgual como se puede convertir un tipo simple como int a constante, se puede declarar const a una estructura compleja. La construcción const MiClase convierte todos los miembros de esta instancia en constantes. Sólo se les pueden asignar un valor en el constructor y después ya no. Se puede forzar una excepción para un campo en la clase declarándolo mutable, pero en general hay poca razón de hacerlo.\r\n\r\nTambién es posible declarar campos individuales constantes dentro de una clase. Por ejemplo, puedo crear una clase que guarde una posición como una posición inicial constante y un desplazamiento variable.\r\n\r\nclass MiSitio\r\n{\r\n    double desplazamiento;          // una variable\r\n    const double posicion_inicial;  // una constante\r\n};\r\nEl valor de posicion_inicial sería asignado en el constructor de la clase y se quedaría inmodificable durante la vida de la instancia. No obstante, cada instancia puede tener otro valor para posicion_inicial. Por lo tanto un miembro constante no es los mismo que una constante global y común a todas las instancias.\r\n\r\nLo que queda por hacer constante son los métodos de una clase. Métodos constantes “prometen” de no modificar ningún dato dentro de la clase. (Más correctamente ninguno que no sea mutable.) Son los únicos métodos que puedo llamar para una instancia constante.\r\n\r\nclass MiCosa\r\n{\r\npublic:\r\n    int mi_variable;\r\n \r\n    void mi_metodo_constante() const\r\n    {\r\n        mi_variable = 0;  // Error de compilación.\r\n        // No debo modificar campos en un método constante.\r\n    };\r\n \r\n    void mi_metodo_variable()\r\n    {\r\n        mi_variable = 0;  // Ok\r\n    };\r\n};\r\n \r\nconst MiCosa cosa;\r\ncosa.mi_metodo_constante();  // Ok\r\ncosa.mi_metodo_variable();   // Error de compilación.\r\n// No puedo llamar a un método NO constante para un objeto constante.\r\nPara complicar la cosa aún más, se pueden definir dos métodos iguales en que una es constante y la otra no. Es algo que usa mucho para los métodos que devuelven iteradores de inicio y final en los contenedores de la STL.\r\n\r\niterator begin(void);\r\nconst_iterator begin(void) const;\r\nEl método constante devuelve un iterador (puntero) a un objeto constante, mientras la versión variable devuelve un iterador a un objeto variable.', NULL),
(80, 7, '7.06', 'Ordenamiento de burbuja mediante llamadas por referencia', 'El ordenamiento por burbuja es bastante sencillo, consiste en evaluar pares de elementos contiguos del arreglo y si el primero es mayor que el siguiente los intercambia (los más chicos quedan abajo). Todo ésto sucede dentro de dos ciclos for que recorren el arreglo. El ciclo más interno realiza las comparaciones, y se asegura ya en la primera pasada completa que el elemento ás grande del arreglo suba a la posición más alta (ésto más adelante nos permitirá desarrollar un algorítmo mejorado del método burbuja).\r\n\r\nEl programa siguiente consta de 3 funciones:\r\n\r\n//La usamos para desplegar los elementos del arreglo.\r\nvoid mostrarArreglo(const int[], int); \r\n\r\n//Es el algoritmo de ordenamiento por burbuja\r\nvoid ordenarArreglo(int[], int);\r\n\r\n/*Esta función es llamada por la función anterior, \r\ny se encarga de intercambiar los pares de elementos\r\ncuando sea necesario. Notar que recibe referencias \r\nya que necesita modificar los valores de sus argumentos.*/\r\nvoid intercambiar(int&, int&);\r\nEjemplo:\r\n//Ordena burbuja, ordenamiento\r\n//de un arreglo metodo burbuja\r\n#include <iostream>\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nvoid mostrarArreglo(const int[], int); //prototipo de funcion que recibe un arreglo constante\r\nvoid ordenarArreglo(int[], int); //prototipo que modifica y ordena elarreglo\r\nvoid intercambiar(int&, int&); //prototipo, intercambialos valores de dos elementos\r\nint main()\r\n{\r\n  const int tamano = 15;\r\n  int arreglo[tamano] = {25,17,13,16,41,32,12,115,95,84,54,63,78,21,10};\r\n  cout << \"Arreglo antes de ordenarse: \" <<endl;\r\n  mostrarArreglo(arreglo,tamano);\r\n  cout << \"Arreglo despues de ordenarse: \" <<endl;\r\n  ordenarArreglo(arreglo,tamano);\r\n  mostrarArreglo(arreglo,tamano);\r\n  cout << \"Fin del programa :)\" << endl;\r\n  return 0;\r\n}//fin de main\r\n\r\nvoid mostrarArreglo(const int arreglo[], int tamano)\r\n{\r\n  for (int i = 0 ; i < tamano ; i++)\r\n    cout << \"arreglo[\"<< i << \"]=\" << arreglo[i]<< endl;\r\n}\r\nvoid ordenarArreglo(int arreglo[], int tamano)\r\n{\r\n  for (int i = 0; i<tamano-1 ; i++)\r\n    for (int j = 0; j<tamano-1 ; j++)\r\n      if(arreglo[j] < arreglo[j+1])\r\n intercambiar(arreglo[j],arreglo[j+1]);\r\n}\r\nvoid intercambiar(int &a, int &b)\r\n{\r\n  int tmp = b;\r\n  b = a;\r\n  a = tmp;\r\n} ', NULL),
(81, 7, '7.07', 'El operador sizeof\r\n', 'El operador unitario sizeof tiene dos formas posibles de sintaxis:\r\n\r\nsizeof expresión-unitaria\r\nsizeof (nombre-de-tipo)\r\nA pesar del aspecto de la segunda forma de sintaxis, se trata de un operador, no de una función. sizeof representa una forma cómoda de obtener información sobre el tamaño de los tipos básicos.\r\n\r\nResultado\r\nCualquiera que sea la forma de sintaxis empleada, el resultado es una constante entera de tipo size_t, con el espacio de memoria (bytes) usada por el operando. Con algunas excepciones, este tamaño es determinado por el tipo de operando, y para cada tipo, depende de la implementación. Es decir, no está predeterminado por el estándar sino por el compilador utilizado.\r\n\r\nEjemplo\r\n#include <iostream.h>\r\nint main(void) {             // ===============\r\n long double ld;\r\n class C { public: float x; float y; } c;\r\n cout << \"Tamaño de ld: \" << sizeof ld << endl;\r\n cout << \"Tamaño de C: \"  << sizeof c << endl;\r\n cout << \"Long double = \" << sizeof(long double) << \" Bytes\" <<  endl;\r\n return 0;\r\n}\r\nSalida:\r\nTamaño de ld: 10\r\nTamaño de C: 8\r\nLong double = 10 Bytes\r\nComentario\r\nCuando se utiliza con instancias de tipos se usa la primera forma de la sintaxis; tanto si se trata de tipos básicos (caso de ld en el ejemplo), como si son tipos definidos por el usuario (caso de C). Cuando se utiliza con especificadores de tipo básicos, se utiliza la segunda, con paréntesis (caso de long double). El operador sizeof no puede ser sobrecargado. Puede utilizarse sizeof en directivas de preprocesador (esto es específico de C++ Builder).\r\n\r\nsizeof con tipos char\r\nCuando el operando es de tipo char (con o sin signo) el resultado es 1. Por definición, el resultado de sizeof(char) es siempre 1. Una definición bastante curiosa, ya que desde siempre estamos acostumbrados a que 1 Byte == 1 Octeto == 8 bits. Pero el estándar ANSI C++ establece que 1 Byte es el espacio de almacenamiento necesitado por un carácter, con independencia del número de bits que ocupe en la máquina; aunque hay que reconocer que (por el momento que sepamos) en todos los sistemas un carácter ASCII se almacena en un octeto. En todos los demás casos, el operador proporciona el número de bytes reales ocupados por el operando. Dicho en otras palabras: podría existir una implementación en la que el 1 resultado de sizeof(char) no significara un \"octeto\", sino otro tamaño.\r\n\r\nsizeof con matrices\r\nCuando el operando es una matriz (que no sea un parámetro), puede utilizarse cualquiera de las dos sintaxis, y el resultado es el tamaño total de la matriz. En otras palabras: la etiqueta de la matriz no es considerada un puntero. El operador sizeof no puede utilizarse con matrices dinámicas o externas. Por ejemplo, el código\r\n\r\nextern int m1[];          // L.1\r\nextern char m2[5];        // L.2\r\nint main () {\r\n ...\r\n cout << \"Tamaño de m1: \" << sizeof m1 << endl;   // L.5  ERROR!!\r\n cout << \"Tamaño de m2: \" << sizeof m2 << endl;   // L.6\r\nproduciría un error de compilación en L.5, ya que aunque la declaración de matriz en L.1 sea correcta, el compilador no dispone de suficiente información para obtener el valor solicitado. En cambio, L.6 compila sin dificultad porque gracias a la declaración L.2 dispone de la información pertinente.\r\n\r\nsizeof con matrices C\r\nLas denominadas matrices \"C\" son conocidas también como NTBS (\"Null Terminated Character String\"), y como constantes de cadena. Por tradición C, se identifican mediante un puntero a su primer carácter. Es decir, por un tipo char*, mientras que el final de cadena se identifica por el carácter nulo. Ejemplo:\r\n\r\nchar* cadena = \"Cadena de caracteres\";\r\nEn estas matrices no es posible utilizar el operador sizeof para determinar el tamaño del objeto-cadena, ya que la sentencia\r\n\r\nstd::cout << sizeof cadena;\r\nsiempre devolverá el tamaño del puntero. En estos casos es posible utilizar la función strlen() de la Librería Estándar para calcular la longitud (tamaño) de la matriz señalada:\r\n\r\nstd::cout << ::strlen(cadena);\r\nEl resultado no incluye el carácter de fin de cadena, y que para un valor correcto se exige que la cadena no incluya caracteres nulos intermedios.\r\n\r\nsizeof con estructura y uniones\r\nCuando se aplica a estructuras o uniones, el operador sizeof devuelve el total de bytes, incluyendo cualquier relleno o alineación interna de los datos Ejemplo:\r\n\r\n#include <iostream.h>\r\nint main(void) {         // ===============\r\n  struct E1 { char c; float f; } e1;\r\n  struct E2 { float f1; float f2; } e2;\r\n  struct E3 { char c; int i; double d; } e3;\r\n  cout << \"Tamaño estr. E1: \" << sizeof(E1) << endl;\r\n  cout << \"Tamaño estr. E2: \" << sizeof(E2) << endl;\r\n  cout << \"Tamaño estr. E3: \" << sizeof(E3) << endl;\r\n}\r\nSalida:\r\nTamaño estr. E1: 8\r\nTamaño estr. E2: 8\r\nTamaño estr. E3: 16\r\nNo se puede utilizar el operador sizeof con expresiones de tipo función; tipos incompletos; nombres parentizados (o tipos análogos), ni campos de bits. La imposibilidad de utilizar este operador con funciones, significa que está orientado a obtener el tamaño de objetos-dato, no de los algoritmos para manipulación de los datos.\r\n\r\nsizeof con clases\r\nDebida a la especialísimas características de las clases, la utilización del operador sizeof con estos tipos requiere algunas consideraciones especiales. La sintaxis empleada es distinta según se trate de un nombre-de-tipo o una instancia concreta. Ejemplo\r\n\r\nclass Cl { long double ld; int i; } c;\r\nclass C2 { public: float x; float y; };\r\ncout << sizeof(C1);       // L.1:\r\ncout << sizeof c;         // L.2:\r\ncout << sizeof(C2);\r\nsize_t\r\nEl resultado producido (devuelto) por el operador sizeof es un entero sin signo denominado de forma estándar size_t, y cuya definición, que depende de la implementación, puede encontrarse en la cabecera <cstddef>]. En el caso de MS Visual C++ 6.0 y Borland C++, el tipo de size_t es unsigned int.', NULL),
(82, 7, '7.08', 'Expresiones con apuntadores y aritmética de apuntadores\r\n', 'Los apuntadores son operandos v´alidos en expresiones aritm´eticas, las expresiones de asignaci´on y las expresiones de comparaci´on. Sin embargo, no todos\r\nlos operadores que se utilizan normalmente en estas expresiones son v´alidos con\r\nvariables de apuntador.\r\nVeremos que operadores pueden tener punteros como operandos y la forma\r\nen que se utilizan.\r\nUn apuntador puede incrementarse (++) o decrementarse ( - -) adem´as es\r\nposible sumar un entero a un apuntador (+ o +=), restar un entero de un apuntador (- o -=) y restar un apuntador de otro.\r\nSuponga se ha declarado un arreglo int v[5] y que su primer elemento est´a en\r\nla localidad 3000 de la memoria. Adem´as suponga se ha inicializado el apuntador vPtr para que apunte a v[0], es decir el valor de vPtr es 3000.vPtr puede\r\ninicializarse mediante cualquiera de las instrucciones:\r\nvPtr=v;\r\no vPtr = &v[0];\r\nen la aritmetica de apuntadores, cuando a un apuntador se suma o resta un\r\nentero, dicho apuntador se incrementa o decrementa en el entero multiplicado\r\npor el tama˜no del objeto hacia el que apunta el apuntador. Por ejemplo\r\nvPtr += 2;\r\nproducir´a 3000 + 2 ∗ 4 = 3008 suponiendo que los enteros se almacenan en 4\r\nbytes de memoria. En el arreglo, vPtr apuntar´a a v[2].\r\nAl efectuar aritm´etica de apuntadores sobre un arreglo de caracteres, los\r\nresultados ser´an consistentes con la aritm´etica com´un pues cada char tiene un\r\nbyte de longitud.\r\nSi vPtr se hubiera incrementado a 3016, que apunta a v[4] la instrucci´on\r\nvPtr -= 4;\r\nestablecer´ıa vPtr nuevamente a 3000. Las instrucciones:\r\n++vPtr;\r\nvPtr++;\r\nincrementan el apuntador para que apunte a la siguiente localidad del arreglo\r\ny\r\n6\r\n- - vPtr;\r\nvPtr - -;\r\ndecrementan el apuntador para que apunte al elemento previo del arreglo.\r\nLa utilizaci´on de aritm´etica de apuntadores sobre un apuntador que no hace\r\nreferencia a un arreglo normalmente es un error de l´ogica. Tambi´en lo es salirse\r\nde cualquiera de los extremos de un arreglo.\r\n', NULL),
(83, 7, '7.09', 'Relación entre apuntadores y arreglos', 'Podemos utilizar intercambiablemente nombres de arreglo y apuntadores.\r\nSuponga hemos declarado un array de enteros b[5] y un puntero a entero\r\nbPtr. Podemos hacer que bPtr apunte al primer elemento del array mediante\r\nbPtr=b;\r\no bPtr=&b[0]\r\nel elemento b[3] del arreglo puede referenciarse mediante\r\n*(bPtr+3)\r\nla direcci´on del tercer elemento se puede escribir como\r\n&b[3]\r\no\r\nbPtr+3\r\nEl arreglo mismo se puede utilizar como apuntador, por ejemplo\r\n*(b+3)\r\ntambi´en se refiere a b[3]. De igual modo se pueden utilizar punteros como si\r\nfueran en nombre del array, por ejemplo:\r\nbPtr[1]\r\nhace referencia a b[1].\r\nComo los nombres de array son apuntadores constantes, la expresi´on\r\nb += 3;\r\nes inv´alida (a diferencia de los apuntadores no contantes).', NULL),
(84, 7, '7.10', 'Arreglos de apuntadores\r\n', 'En muchas ocasiones, es muy útil declarar un array de punteros. Es muy común cuando queremos tener un array de cadenas de caracteres. Si una cadena de caracteres puede escribirse como char *c; un array de cadenas de caracteres podrá escribirse como char **c; o char *c[x];.\r\n\r\nDado el array de punteros siguiente:\r\n\r\n#define SIZE 7\r\nchar *str[SIZE] = {\"Lunes\",\r\n                \"Martes\",\r\n                \"Miércoles\",\r\n                \"Jueves\",\r\n                \"Viernes\",\r\n                \"Sábado\",\r\n                \"Domingo\"};\r\nCrea un fichero llamándole arrays_of_pointers.c e implementa una función con el prototipo void print_strings(char **str); que imprima por pantalla las 7 cadenas.', NULL);
INSERT INTO `indices` (`id_indices`, `id_capitulo`, `numero_ind`, `nombre_ind`, `descripcion_ind`, `indice_id`) VALUES
(85, 7, '7.11', 'Ejemplo práctico: Simulación para barajar y repartir cartas\r\n', '\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n \r\n/* prototipos */\r\nvoid baraja( int wMazo[][ 13 ] );\r\nvoid reparte( const int wMazo[][ 13 ], const char *wCara[], \r\n           const char *wPalo[] );\r\n \r\nint main()\r\n{\r\n   /* inicializa el arreglo palo */\r\n   const char *palo[ 4 ] = { \"Corazones\", \"Diamantes\", \"Treboles\", \"Espadas\" };\r\n   \r\n   /* inicializa el arreglo cara */\r\n   const char *cara[ 13 ] = \r\n      { \"As\", \"Dos\", \"Tres\", \"Cuatro\", \r\n        \"Cinco\", \"Seis\", \"Siete\", \"Ocho\",\r\n        \"Nueve\", \"Diez\", \"Sota\", \"Reyna\", \"Rey\" };\r\n \r\n   /* inicializa el arreglo mazo */\r\n   int mazo[ 4 ][ 13 ] = { 0 };\r\n \r\n   srand( time( 0 ) ); /* semilla del generador de nÃƒÂºmeros aleatorios */\r\n \r\n   baraja( mazo );\r\n   reparte( mazo, cara, palo );\r\n \r\n   return 0; /* indica terminaciÃƒÂ³n exitosa */\r\n \r\n} /* fin de main */\r\n \r\n/* baraja las cartas del mazo */\r\nvoid baraja( int wMazo[][ 13 ] )\r\n{\r\n   int fila;    /* nÃƒÂºmero de fila */\r\n   int columna; /* nÃƒÂºmero de columna */\r\n   int carta;   /* contador */\r\n \r\n   /* elige aleatoriamente un espacio para cada una de las 52 cartas */\r\n   for ( carta = 1; carta <= 52; carta++ ) {\r\n \r\n      /* elije una nueva ubicaciÃƒÂ³n al azar hasta que encuentra un espacio vacÃƒÂ­o  */\r\n      do {\r\n         fila = rand() % 4;\r\n         columna = rand() % 13;\r\n      } while( wMazo[ fila ][ columna ] != 0 ); /* fin de do...while */\r\n \r\n      /* coloca el nÃƒÂºmero de carta en el espacio vacÃƒÂ­o del mazo */\r\n      wMazo[ fila ][ columna ] = carta;\r\n   } /* fin de for */\r\n \r\n} /* fin de la funciÃƒÂ³n baraja */\r\n \r\n/* reparte las cartas del mazo */\r\nvoid reparte( const int wMazo[][ 13 ], const char *wCara[],\r\n           const char *wPalo[] )\r\n{\r\n   int carta;   /* contador de cartas */\r\n   int fila;    /* contador de filas */\r\n   int columna; /* contador de columnas */\r\n \r\n   /* reparte cada una de las 52 cartas */\r\n   for ( carta = 1; carta <= 52; carta++ ) {\r\n \r\n      /* realiza el ciclo a travÃƒÂ©s de las filas de wMazo */\r\n      for ( fila = 0; fila <= 3; fila++ ) {\r\n \r\n         /* realiza el ciclo a travÃƒÂ©s de las columnas de wMazo en la fila actual */\r\n         for ( columna = 0; columna <= 12; columna++ ) {\r\n \r\n            /* si el espacio contiene la carta actual, despliega la carta */\r\n            if ( wMazo[ fila ][ columna ] == carta ) {\r\n               printf( \"%6s de %-9s%c\", wCara[ columna ], wPalo[ fila ],\r\n                  carta % 2 == 0 ? \'n\' : \'t\' );\r\n            } /* fin de if */\r\n \r\n         } /* fin de for */\r\n \r\n      } /* fin de for */\r\n \r\n   } /* fin de for */\r\n \r\n} /* fin de la funciÃƒÂ³n reparte */', NULL),
(86, 7, '7.12', 'Apuntadores a funciones\r\n', 'Un apuntador a una funci´on contiene la direcci´on que tiene la funci´on en la\r\nmemoria. Un nombre de funci´on es la direcci´on inicial en memoria del c´odigo\r\nque lleva a cabo la tarea de la funci´on.\r\nLos apuntadores a funciones pueden ser pasados a las funciones, devueltos\r\npor ellas, almacenados en arreglos y asignados a otros apuntadores a funciones.\r\nConsideremos como ejemplo el programa de la burbuja. La funci´on burbuja\r\nrecibe como argumento un apuntador a una funci´on. Las funciones cuyo apuntador pasamos como argumento son : ascendente y descendente.\r\nEl programa le pide al usuario que seleccione si el arreglo debe ordenarse en\r\nforma ascendente o descendente.\r\nVeamos el programa (suponemos intercambio est´a definida):\r\nint ascendente (int a, int b)\r\n{ return b<a; }\r\n9\r\nint descendente (int a, int b)\r\n{ return b>a; }\r\nvoid burbuja(int A[],const int tamanio,int (*compare)(int,int))\r\n{\r\nfor(int i=1;i<tamanio;i++)\r\nfor(j=0;j<tamanio-1;j++)\r\nif ((*compare)(A[j],A[j+1]))\r\nintercambio(&A[j],&A[j+1]);\r\n}\r\nobservaciones:\r\n&A[i] y A+i son identicas.\r\nSi pa es un apuntador con la direcci´on de a, entonces pa[i] es identico a *(pa+i).\r\nLas llamadas a burbuja ser´an en la forma:\r\nburbuja(A,n,ascending);\r\ny\r\nburbuja(A,n,descending)\r\nEl siguiente par´ametro aparece en el encabezado de la funci´on burbuja:\r\nint (*compare)(int,int)\r\nesto le dice a burbuja que espere un par´ametro que es un apuntador a una\r\nfunci´on que recibe dos par´ametros enteros y devuelve un resultado entero. Se\r\nnecesitan parentesis alrededor de compare porque * tiene menor precedencia\r\nque el par´entesis que encierra los par´ametros de la funci´on. Si no se hubieran\r\nincluido los par´entesis la declaraci´on habr´ıa sido\r\nint *compare(int,int)\r\nque declara una funci´on que recibe dos enteros y devuelve un apuntador a\r\nentero.\r\nEl par´ametro correspondiente al prototipo de funci´on de burbuja es\r\nint (*)(int,int)\r\nUno de los usos de los apuntadores a funciones es en los sistemas operados\r\npor men´us. Al usuario se le solicita desde un men´u que de una opci´on. Cada\r\nopci´on es atendida por una funci´on distinta. En un arreglo de apuntadores a\r\nfunciones se almacenan los apuntadores a las funciones. Se toma la selecci´on del\r\nusuario como subindice del arreglo. Ejemplo:\r\nsupongamos tenemos funciones : funcion1, funcion2, funcion3 que tienen un\r\nentero como argumento. Los prototipos son:\r\nvoid function1(int);\r\nvoid function2(int);\r\nvoid function3(int);\r\n10\r\ninicializamos el arreglo con:\r\nvoid (*f[3])(int) = {funcion1,funcion2,funcion3};\r\ninvocamos la funci´on con indice i y argumento j como sigue:\r\n(*f[i])(j)', NULL),
(87, 8, '8.01', 'Introducción', 'Vamos ahora a ver cómo manejar texto con C. Para empezar, es preciso decir que existe un tipo string como en otros lenguajes, pero no existe un tipo de datos específico para almacenar texto, sino que se utilizan arrays de char. Funcionan igual que los demás arrays con la diferencia de que ahora se manejan letras en vez de números. Se les llama cadenas, strings o tiras de caracteres y  a partir de ahora les llamaremos cadenas.', NULL),
(88, 8, '8.02', 'Fundamentos de cadenas y caracteres', 'Para declarar una cadena se hace como en el caso de un array. Por ejemplo, si queremos declarar una cadena de longitud 20 caracteres se haría:\r\n\r\n	char texto[20];\r\n\r\nAl igual que en los arrays, no podemos entonces introducir más de 20 elementos en la cadena. Vamos a ver un ejemplo para mostrar el nombre del usuario en pantalla:\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n{\r\n	char nombre[20];\r\n\r\n	printf( \"Introduzca su nombre (20 letras máximo): \" );\r\n	scanf( \"%s\", nombre );\r\n	printf( \"\\nEl nombre que ha escrito es: %s\\n\", nombre );\r\n}\r\nObsérvese que en la sentencia scanf no se usa el símbolo & delante de nombre. No hace falta porque se trata de un array, de modo que escribir el nombre del array es equivalente a poner &nombre[0].\r\n\r\nTambién puede llamar la atención sobre la forma de imprimir el array. Con sólo usar %s ya se imprime su totalidad. Ya veremos esto más adelante.\r\n\r\nPor si alguien está acostumbrado a programar en otro lenguaje es preciso hacer notar que en C no se puede hacer esto:\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n{\r\n	char texto[20];\r\n\r\n	texto = \"Hola\";\r\n}\r\nEs interesante saber cómo funciona una cadena por dentro, por eso vamos a ver primero cómo se inicializa:\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n{\r\n	char nombre[] = \"Gandalf\";\r\n\r\n	printf( \"Texto: %s\\n\", nombre );\r\n	printf( \"Tamaño de la cadena: %i bytes\\n\", sizeof nombre );\r\n}\r\nResultado al ejecutar:\r\n\r\nTexto: Gandalf\r\nTamaño de la cadena: 8 bytes\r\nCuriosamente la respuesta nos dice que \"Gandalf\" ocupa 8 bytes. Como cada elemento char ocupa un byte eso quiere decir que la cadena tiene 8 elementos, a pesar de que \"Gandalf\" sólo cuenta con 7 letras. La razón de esta aparente paradoja estriba en que la cadena tiene como carácter final el símbolo \'\\0\', cuyo significado es \"fin de cadena\". De esta forma, cuando queremos escribir la cadena basta con usar %s y el compilador sabe cuántos elementos debe escribir: hasta que encuentre \'\\0\'.\r\n\r\nEl programa anterior sería equivalente a:\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n{\r\n	char nombre[] = { \'G\', \'a\', \'n\', \'d\', \'a\', \'l\', \'f\', \'\\0\' };\r\n\r\n	printf( \"Texto: %s\\n\", nombre );\r\n	printf( \"Tamaño de la cadena: %i bytes\\n\", sizeof nombre );\r\n}\r\nAquí ya se observa claramente que nombre tiene 8 elementos. Pero, ¿qué pasaría si no pusiéramos \'\\0\' al final?\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n{\r\n	char nombre[] = { \'G\', \'a\', \'n\', \'d\', \'a\', \'l\', \'f\' };\r\n\r\n	printf( \"Texto: %s\\n\", nombre );\r\n	printf( \"Tamaño de la cadena: %i bytes\\n\", sizeof nombre );\r\n}\r\nEn mi ordenador se obtiene:\r\n\r\nTexto: Gandalf-\r\nTamaño de la cadena: 7 bytes\r\nPero en otro después de \"Gandalf\" puede aparecer cualquier cosa. Lo que aquí sucede es que printf no encuentra el símbolo \'\\0\' y no sabe cuándo dejar de imprimir. Afortunadamente, cuando introducimos una cadena se hace de la primera forma y el C se encarga de poner el símbolo al final.\r\n\r\nEs importante no olvidar que la longitud de una cadena es la longitud del texto más el símbolo de fin de cadena. Por eso cuando definamos una cadena tenemos que reservarle un espacio adicional. Por ejemplo:\r\n\r\n	char nombre[8] = \"Gandalf\";\r\nVolver al principio de página\r\n\r\n\r\n \r\n\r\nFunciones de manejo de cadenas\r\nExisten unas cuantas funciones el la biblioteca estándar de C para el manejo de cadenas:\r\n\r\nstrlen\r\nstrcpy\r\nstrcat\r\nsprintf\r\nstrcmp\r\nPara usar estas funciones en nuestro programa hay que añadir la directiva:\r\n\r\n#include <string.h>\r\n \r\n	\r\nstrlen\r\nsize_t *strlen(const char *cadena);\r\nEsta función devuelve el número de caracteres que tiene la cadena (sin contar el \'\\0\'). \r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char texto[]=\"Gandalf\";\r\n	int longitud;\r\n	longitud = strlen(texto);\r\n	printf( \"La cadena \\\"%s\\\" tiene %i caracteres.\\n\", texto, longitud );\r\n}\r\nComo ejemplo, vamos a ver cómo se programaría esta función si no dispusiéramos de ella. Hay más información en Recorrido de cadenas con punteros.\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char texto[]=\"Gandalf\";\r\n	char *p;\r\n	int longitud=0;\r\n\r\n	p = texto;\r\n	while (*p != \'\\0\') {\r\n		longitud++;\r\n		printf( \"%c\\n\", *p );	/* Mostramos la letra actual */\r\n		p++;			/* Vamos a la siguiente letra */\r\n	}\r\n	printf( \"La cadena \\\"%s\\\" tiene %i caracteres.\\n\", texto, longitud );\r\n}\r\nPara medir la longitud de la cadena usamos un puntero para recorrerla (el puntero p). Hacemos que p apunte a texto. Luego entramos en un bucle while. La condición del bucle comprueba si se ha llegado al fin de cadena (\'\\0\'). Si no es así, suma 1 a longitud, muestra la letra por pantalla e incrementa el puntero en 1 (con lo que pasamos a la siguiente letra).\r\n\r\n Volver a funciones de manipulación de cadenas\r\n\r\n	\r\nstrcpy\r\nchar *strcpy(char *cadena1, const char *cadena2);\r\nCopia el contenido de cadena2 en cadena1. cadena2 puede ser una variable o una cadena directa (por ejemplo, \"hola\"). Debemos tener cuidado de que la cadena destino (cadena1) tenga espacio suficiente para albergar a la cadena origen (cadena2).\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char texto[] = \"Éste es un curso de C.\";\r\n	char destino[50];\r\n\r\n	strcpy( destino, texto );\r\n	printf( \"Valor final: %s\\n\", destino );\r\n}\r\nVamos a ver otro ejemplo en el que la cadena destino es una cadena constante (\"Éste es un curso de C.\") y no una variable. Además, en este ejemplo vemos que la cadena origen es sustituida por la cadena destino totalmente. Si la cadena origen es más larga que la destino, se eliminan las letras adicionales.\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char destino[50]=\"Éste no es un curso de HTML, sino de C.\";\r\n\r\n	printf( \"%s\\n\", destino );\r\n	strcpy( destino, \"Éste es un curso de C.\" );\r\n	printf( \"%s\\n\", destino );\r\n}\r\n Volver a funciones de manipulación de cadenas\r\n\r\n	\r\nstrcat\r\nchar *strcat(char *cadena1, const char *cadena2);\r\nAñade la cadena2 al final de la cadena1 (concatena).\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char nombre_completo[50];\r\n	char nombre[]=\"Gandalf\";\r\n	char apellido[]=\"el Gris\";\r\n\r\n	strcpy( nombre_completo, nombre );\r\n	strcat( nombre_completo, \" \" );\r\n	strcat( nombre_completo, apellido );\r\n	printf( \"El nombre completo es: %s.\\n\", nombre_completo );\r\n}\r\nComo siempre, tenemos asegurar que la variable en la que añadimos las demás cadenas tenga el tamaño suficiente. Con la primera línea de este programa introducimos el nombre en nombre_completo. Usamos strcpy para asegurarnos de que queda borrado cualquier dato anterior. Luego usamos un strcat para añadir un espacio y, finalmente, introducimos el apellido.\r\n\r\n Volver a funciones de manipulación de cadenas\r\n\r\n	\r\nsprintf\r\nint sprintf(char *destino, const char *format, ...);\r\nFunciona de manera similar a printf pero, en vez de mostrar el texto en la pantalla, lo guarda en una variable (destino). El valor que devuelve (int) es el número de caracteres guardados en la variable destino.\r\n\r\nCon sprintf podemos repetir el ejemplo de strcat de manera más sencilla:\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char nombre_completo[50];\r\n	char nombre[]=\"Gandalf\";\r\n	char apellido[]=\"el Gris\";\r\n\r\n	sprintf( nombre_completo, \"%s %s\", nombre, apellido );\r\n	printf( \"El nombre completo es: %s.\\n\", nombre_completo );\r\n}\r\nSe puede aplicar a sprintf todo lo indicado para printf.\r\n\r\n Volver a funciones de manipulación de cadenas\r\n\r\n	\r\nstrcmp\r\nint strcmp(const char *cadena1, const char *cadena2);\r\nCompara cadena1 y cadena2. Si son iguales, devuelve 0. Un número negativo si cadena1 \"va\" antes que cadena2, y un número positivo si es al contrario:\r\n\r\n< 0    si    cadena1 < cadena2\r\n==0    si    cadena1 == cadena2\r\n> 0    si    cadena1 > cadena2\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char nombre1[]=\"Gandalf\";\r\n	char nombre2[]=\"Frodo\";\r\n\r\n	printf( \"Comparación con strcmp: %i\\n\", strcmp(nombre1,nombre2));\r\n}\r\nEl resultado es:\r\n\r\nComparación con strcmp : 1\r\nVolver al principio de página\r\n\r\n\r\n \r\n\r\nArrays de cadenas\r\nUn array de cadenas puede servirnos para agrupar una serie de mensajes. Por ejemplo, todos los mensajes de error de un programa. Luego, para acceder a cada mensaje, basta con usar su número.\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint error( int num_err )\r\n{\r\n	char *errores[] = {\r\n		\"No se ha producido ningún error\",\r\n		\"No hay suficiente memoria\",\r\n		\"No hay espacio en disco\",\r\n		\"Me he cansado de trabajar\"\r\n		};\r\n\r\n	printf( \"Error número %i: %s.\\n\", num_err, errores[num_err] );\r\n	exit( -1 );\r\n}\r\n\r\n\r\nmain()\r\n{\r\n	error( 2 );\r\n}\r\nEl resultado será:\r\n\r\nError número 2: No hay espacio en disco.\r\nUn array de cadenas es en realidad un array de punteros a cadenas. El primer elemento de la cadena (\"No se ha producido ningún error\") tiene un espacio reservado en memoria y errores[0] apunta a ese espacio.\r\n\r\nOrdenación de un array de cadenas\r\nVamos a ver un sencillo ejemplo de ordenación de cadenas. En el ejemplo siguiente tenemos que ordenar una serie de dichos populares:\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define ELEMENTOS 5\r\n\r\nmain()\r\n{\r\n	char *dichos[ELEMENTOS] = {\r\n		\"La avaricia rompe el saco\",\r\n		\"Más vale pájaro en mano que ciento volando\",\r\n		\"No por mucho madrugar amanece más temprano\",\r\n		\"Año de nieves, año de bienes\",\r\n		\"A caballo regalado no le mires el diente\"\r\n		};\r\n	char *temp;\r\n	int i, j;\r\n\r\n	printf( \"Lista desordenada:\\n\" );\r\n	for( i=0; i<ELEMENTOS; i++ )\r\n		printf( \"  %s.\\n\", dichos[i] );\r\n\r\n	for( i=0; i<ELEMENTOS-1; i++ )\r\n		for( j=i+1; j<ELEMENTOS; j++ )\r\n			if ( strcmp(dichos[i], dichos[j]) > 0 ) {\r\n				temp = dichos[i];\r\n				dichos[i] = dichos[j];\r\n				dichos[j] = temp;\r\n			}\r\n\r\n	printf( \"Lista ordenada:\\n\" );\r\n	for( i=0; i<ELEMENTOS; i++ )\r\n		printf( \"  %s.\\n\", dichos[i] );\r\n}\r\nCómo funciona el programa:\r\n\r\ntomamos el primer elemento de la matriz. Lo comparamos con todos los siguientes. Si alguno es anterior, los intercambiamos. Cuando acabe esta primera vuelta tendremos \"A caballo regalado no le mires el diente\" en primera posición.\r\nTomamos el segundo elemento. Lo comparamos con el tercero y siguientes. Si alguno es anterior, los intercambiamos. Al final de esta vuelta quedará \"A caballo regalado no le mires el diente\" en segunda posición.\r\nPara ver con mayor claridad el resultado a partir del desarrollo del proceso, se va a sustituir cada cadena por su primera letra (menos la de \"Año de nieves...\" que se sustituirá por Añ). Así, el proceso queda:\r\n\r\n   0    1    2    3    3\'   4    4\'   5    6    6\'   7    7\'   8    8\'   9    9\'   10  10\'\r\n1  L    L    L    L    Añ   Añ   A\r\n2  M    M    M    M    M    M    M    M    M    L    L    Añ\r\n3  N    N    N    N    N    N    N    N    N    N    N    N    N    M    M    L\r\n4  Añ   Añ   Añ   Añ   L    L    L    L    L    M    M    M    M    N    N    N    N    M\r\n5  A    A    A    A    A    A    Añ   Añ   Añ   Añ   Añ   L    L    L    L    M    M    N\r\nVolver al principio de página\r\n\r\n\r\n \r\n\r\nRecorrido de cadenas con punteros\r\nLas cadenas se pueden recorrer de igual forma que se hace con los arrays, usando punteros. Vamos a ver un ejemplo: el siguiente sencillo programa cuenta los espacios y las letras e (minúsculas) que hay en una cadena.\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char cadena[]=\"El puerto paralelo del PC\";\r\n	char *p;\r\n	int espacios = 0, letras_e = 0;\r\n\r\n	p = cadena;\r\n	while (*p != \'\\0\') {\r\n		if (*p == \' \') espacios++;\r\n		if (*p == \'e\') letras_e++;\r\n		p++;\r\n	}\r\n\r\n	printf( \"En la cadena \\\"%s\\\" hay:\\n\", cadena );\r\n	printf( \"  %i espacios\\n\", espacios );\r\n	printf( \"  %i letras e\\n\", letras_e );\r\n}\r\nEl resultado es:\r\n\r\nEn la cadena \"El puerto paralelo del PC\" hay:\r\n  4 espacios\r\n  3 letras e\r\nPara recorrer la cadena necesitamos un puntero p que sea de tipo char. Debemos hacer que p apunte a la cadena (p=cadena). Así, p apunta a la dirección del primer elemento de la misma. El valor de *p sería, por tanto, \'E\'. Comenzamos el bucle. La condición comprueba que no se ha llegado al final de la cadena (*p != \'\\0\'). Entonces se comprueba si en la dirección a la que apunta p hay un espacio o una letra e. Si es así, se incrementan las variables correspondientes. Una vez comprobado esto se pasa a la siguiente letra (p++).\r\n\r\nEn este otro ejemplo substituimos los espacios por guiones:\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nmain()\r\n{\r\n	char cadena[]=\"El puerto paralelo del PC\";\r\n	char *p;\r\n\r\n	p = cadena;\r\n	while (*p != \'\\0\') {\r\n		if (*p == \' \') *p = \'-\';\r\n		p++;\r\n	}\r\n\r\n	printf( \"La cadena queda: \\\"%s\\\" \\n\", cadena );\r\n}\r\ny se obtiene:\r\n\r\nLa cadena queda: \"El-puerto-paralelo-del-PC\"\r\n', NULL),
(89, 8, '8.03', 'La biblioteca de manipulación de caracteres\r\n', '\r\nLa biblioteca <string.h> contiene un conjunto de funciones para manipular cadenas: copiar, cambiar caracteres, comparar cadenas, etc.\r\nLas funciones más elementales son:\r\n\r\nstrcpy ( c1, c2 ); Copia c2 en c1\r\nstrcat ( c1, c2 ); Añade c2 al final de c1\r\nint strlen ( cadena ); Devuelve la longitud de la cadena\r\nint strcmp ( c1, c2 ); Devuelve cero si c1 es igual a c2;\r\nno-cero en caso contrario\r\n\r\nPara trabajar con estas funciones, al comienzo del programa hay que escribir\r\n\r\n	#include <string.h>\r\n\r\nEjemplo:\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar completo [80];\r\n\r\nchar nombre[32] = \"Pedro\";\r\nchar apellidos [32] = \"Medario Arenas\";\r\n\r\nmain()\r\n{\r\n  /* Construye el nombre completo */\r\n\r\n  strcpy ( completo, nombre );	/* completo <- \"Pedro\" */\r\n  strcat ( completo, \" \");	  	/* completo <- \"Pedro \" */\r\n  strcat ( completo, apellidos );	/* completo <- \"Pedro \r\n							   Medario Arenas\" */\r\n\r\n  printf ( \"El nombre completo es %s\\n\", completo );\r\n\r\n}', NULL),
(90, 8, '8.04', 'Funciones de conversión de cadenas\r\n', 'Cadenas de Caracteres.\r\nFunciones Asociadas al Manejo de cadenas de caracteres\r\nAunque C no incorpora en su definición operadores para el manejo de cadenas de caracteres, todo compilador de C proporciona una librera estándar (string.h) con funciones para facilitar su utilización. Destacar algunas de ellas:\r\n\r\nstrcpy: La función strcpy se encuentra en la biblioteca <string.h> y se utiliza para copiar una cadena de caracteres (fuente) en el lugar que ocupaba otra (destino). Esta copia es destructiva, o sea, que todos los caracteres que estaban en la cadena destino desaparecen, aunque la cadena destino fuera más larga que la cadena fuente .La cadena destino se pone como primer argumento de la función y la cadena fuente como segundo. Vamos a verlo con un ejemplo.\r\n\r\n#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main() \r\n{\r\n    char texto1[]=\"corta\"; \r\n    char texto2[]=\"mediana\"; \r\n    char texto3[]=\"larguisima\";\r\n\r\n    strcpy(texto2,texto1); \r\n    printf(\"%s\\n\",texto2); \r\n    strcpy(texto2,texto3); \r\n    printf(\"%s\\n\",texto2); \r\n    getch();\r\nreturn 0; \r\n}	\r\n\r\nstrcat: En el programa anterior vimos que la función strcpy es desctructiva, pero hay otra función en la librería <string.h> que copia una cadena (fuente) en otra (destino) sin destruir ésta, es decir, que copia una cadena detrás de la otra esta función es conocida como strcat. Vamos a hacer un ejemplo:\r\n\r\n#include<stdio.h> \r\n#include<string.h>\r\nint main()\r\n{\r\n    char texto1[]=\"Don Pepito\"; \r\n    char texto2[]=\" y \"; \r\n    char texto3[]=\"Don Jose\";printf(\"%s\\n\",texto1);\r\n\r\n    strcat(texto1,texto2);\r\n    printf(\"%s\\n\",texto2);  \r\n    strcat(texto1,texto3); \r\n    printf(\"%s\\n\",texto2);\r\n    getchar(); \r\nreturn 0; \r\n}	\r\n\r\nstrlen: esta función devuelve el total (entero) de caracteres que conforman una cadena (excluyendo el caracter nulo \\0). Vamos a hacer un ejemplo:\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <conio.h>\r\n#define MAXLON 80\r\n\r\nint main(void)\r\n{\r\n    char a[MAXLON+1];\r\n    int longitud;\r\n    \r\n    clrscr(); \r\n    printf (\"Introduce una cadena (max. %d caracteres): \", MAXLON);\r\n    scanf(\"%s\",&a); \r\n    longitud = strlen(a);\r\n    printf (\"\\nLongitud de la cadena: %d\\n\", longitud);\r\n    getch();\r\nreturn 0; \r\n}\r\nstrcmp: strcmp (abreviatura de ((string comparison))). La función strcmp recibe dos cadenas, a y b, devuelve un entero. El entero que resulta de efectuar la llamada strcmp(a, b) codifica el resultado de la comparación:\r\n\r\nes menor que cero si la cadena a es menor que b,\r\n\r\nes 0 si la cadena a es igual que b, y\r\n\r\nes mayor que cero si la cadena a es mayor que b.\r\n\r\nNaturalmente, menor significa que va delante en orden alfabético, y mayor que va detrás.\r\n\r\n#include <stdio.h> \r\n#include <string.h>\r\nint main() \r\n{\r\n    char s1[6] = \"Abeja\"; \r\n    char s2[6] = \"abeja\"; \r\n    int i;\r\n    \r\n    printf( \"s1=%s\\t\", s1 ); \r\n    printf( \"s2=%s\\n\", s2 );\r\n    \r\n    i = strcmp( s1, s2 ); \r\n    printf( \"s1 es \" );\r\n    if( i < 0 ) printf( \"menor que\" );\r\n    else if( i > 0 ) printf( \"mayor que\" );\r\n    else printf( \"igual a\" ); \r\n    printf( \" s2\\n\" );\r\n\r\nreturn 0; \r\n}\r\n\r\nOtras Funciones útiles para operar cadenas de caracteres.\r\nNo sólo string.h contiene funciones útiles para el tratamiento de cadenas. En ctype.h se encuentran unas funciones que permiten hacer cómodamente preguntas acerca de los caracteres, como si son mayúsculas, minúsculas, dígitos, etc:\r\n\r\nisalnum(caracter): devuelve cierto (un entero cualquiera distinto de cero) si caracter es una letra o dígito, y falso (el valor entero 0) en caso contrario.\r\n\r\nisalpha(caracter): devuelve cierto si caracter es una letra, y falso en caso contrario.\r\n\r\nisblank(caracter): devuelve cierto si caracter es un espacio en blanco o un tabulador.\r\n\r\nisdigit(caracter) devuelve cierto si caracter es un digito, y falso en caso contrario.\r\n\r\nisspace(caracter): devuelve cierto si caracter es un espacio en blanco, un salto de línea, un retorno de carro, un tabulador, etc., y falso en caso contrario.\r\n\r\nislower(caracter): devuelve cierto si caracter es una letra minúscula, y falso en caso contrario.\r\n\r\nisupper(caracter): devuelve cierto si caracter es una letra mayúscula, y falso en caso contrario.\r\n\r\ntoupper(caracter): devuelve la mayúscula asociada a caracter, si la tiene; si no, devuelve el mismo caracter.\r\n\r\ntolower(caracter): devuelve la minúscula asociada a caracter, si la tiene; si no, devuelve el mismo caracter.', NULL),
(91, 8, '8.05', 'Funciones de entrada/salida de la biblioteca estándar\r\n', 'Entrada y salida de datos en C\r\nEl lenguaje C va acompañado de una colección de funciones de biblioteca que incluye un cierto número de funciones de entrada/salida. Como norma general, el archivo de cabecera requerido para la entrada/salida estándar se llama stdio.h, entre todas las funciones que contiene algunas de las más usadas son: getchar, putchar, scanf, printf, gets y puts. Estas seis funciones permiten la transferencia de información entre la computadora y los dispositivos de entrada/salida estándar tales como un teclado y un monitor.\r\n\r\nEn las siguientes subsecciones se describen únicamente las características básicas de las funciones getchar, putchar, scanf, printf, gets y puts..\r\n\r\nEntrada de un carácter: función getchar\r\nMediante la función de biblioteca getchar se puede conseguir la entrada de un carácter a través del dispositivo de entrada estándar, usualmente el teclado. Su sintaxis es\r\n\r\nvariable = getchar();\r\n\r\ndonde variable es alguna variable de tipo carácter declarada previamente.\r\n\r\nEjemplo 1.17:\r\nchar c;\r\n\r\nc=getchar();\r\n\r\nEn la primera instrucción se declara la variable c de tipo carácter. La segunda instrucción hace que se lea del dispositivo de entrada estándar un carácter y entonces se le asigne a c.\r\n\r\nSalida de un carácter: función putchar\r\nMediante la función de biblioteca putchar se puede conseguir la salida de un carácter a través del dispositivo de salida estándar, usualmente el monitor. Su sintaxis es\r\n\r\nputchar(variable);\r\n\r\ndonde variable es alguna variable de tipo carácter declarada previamente.\r\n\r\nEjemplo 1.18:\r\nchar c=\'a\';\r\n\r\nputchar(c);\r\n\r\nEn la primera instrucción se declara la variable c de tipo carácter. La segunda instrucción hace que se visualice el valor de c en el dispositivo de salida estándar (monitor).\r\n\r\nIntroducción de datos: función scanf\r\nMediante la función de biblioteca scanf se puede introducir datos en la computadora a través del dispositivo de entrada estándar. Esta función permite introducir cualquier combinación de valores numéricos, caracteres sueltos y cadenas de caracteres. La función devuelve el número de datos que se han conseguido introducir correctamente. Su sintaxis es\r\n\r\nscanf(cadena de control,arg1,arg2,...,argN);\r\n\r\ndonde cadena de control hace referencia a una cadena de caracteres que contiene cierta información sobre el formato de los datos y arg1,arg2,...,argN son argumentos (punteros) que indican la direcciones de memoria donde se encuentran los datos.\r\n\r\nEn la cadena de control se incluyen grupos individuales de caracteres, con un grupo de caracteres por cada dato de entrada. Cada grupo de caracteres debe comenzar con el signo de porcentaje %. En su forma más sencilla, un grupo de caracteres estará formado por el signo de porcentaje, seguido de un carácter de conversión que indica el tipo de dato correspondiente. En la Tabla 1.8 se muestran los caracteres de conversión de los datos de entrada de uso común.\r\n\r\nLos argumentos pueden ser variables o arrays, y sus tipos deben coincidir con los indicados por los grupos de caracteres correspondientes en la cadena de control. Cada nombre de variable debe ser precedido por un ampersand (&), salvo en el caso de los arrays.\r\n\r\nCarácter de conversión\r\n\r\nSignificado del dato\r\n\r\nc\r\n\r\nCarácter\r\n\r\nd\r\n\r\nEntero decimal\r\n\r\ne\r\n\r\nComa flotante\r\n\r\nf\r\n\r\nComa flotante\r\n\r\ng\r\n\r\nComa flotante\r\n\r\nh\r\n\r\nEntero corto\r\n\r\no\r\n\r\nEntero octal\r\n\r\ns\r\n\r\nCadena de caracteres seguida de un carácter de espaciado.\r\n\r\nu\r\n\r\nEntero decimal sin signo\r\n\r\n[...]\r\n\r\nCadena de caracteres que puede incluir caracteres de espaciado.\r\n\r\n\r\n\r\nTabla 1.8: Caracteres de conversión de los datos de entrada de uso común\r\n\r\nEjemplo 1.19:\r\n#include <stdio.h>\r\n\r\nmain()\r\n\r\n{\r\n\r\nchar concepto[20];\r\n\r\nint no_partida;\r\n\r\nfloat coste;\r\n\r\nscanf(\"%s %d %f\", concepto, &no_partida, &coste);\r\n\r\n}\r\n\r\nDentro de la función scanf de este programa, la cadena de control es \"%s %d %f\". Contiene tres grupos de caracteres. El primer grupo, %s, indica que el primer argumento (concepto) representa a una cadena de caracteres. El segundo grupo, %d, indica que el segundo argumento (&no_partida) representa un valor entero decimal, y el tercer grupo, %f, indica que el tercer argumento (&coste) representa un valor en coma flotante.\r\n\r\nObsérvese, que las variables numéricas no_partida y coste van precedidas por ampersands dentro de la función scanf. Sin embargo, delante de concepto no hay ampersand, ya que concepto es el nombre del array.\r\n\r\nEscritura de datos: función printf\r\nMediante la función de biblioteca printf se puede escribir datos en el dispositivo de salida estándar. Esta función permite escribir cualquier combinación de valores numéricos, caracteres sueltos y cadenas de caracteres. Su sintaxis es\r\n\r\nprintf(cadena de control,arg1,arg2,...,argN);\r\n\r\ndonde cadena de control hace referencia a una cadena de caracteres que contiene información sobre el formato de salida y arg1,arg2,...,argN son argumentos que representan los datos de salida.\r\n\r\nLa cadena de control está compuesta por grupos de caracteres, con un grupo de caracteres por cada dato de salida. Cada grupo de caracteres debe empezar por un signo de porcentaje (%). En su forma sencilla, un grupo de caracteres consistirá en el signo de porcentaje seguido de un carácter de conversión que indica el tipo de dato correspondiente. En la Tabla 1.9 se muestran los caracteres de conversión de los datos de salida de uso común.\r\n\r\nCarácter de conversión\r\n\r\nSignificado del dato visualizado\r\n\r\nc\r\n\r\nCarácter\r\n\r\nd\r\n\r\nEntero decimal con signo\r\n\r\ne\r\n\r\nComa flotante con exponente\r\n\r\nf\r\n\r\nComa flotante sin exponente\r\n\r\ng\r\n\r\nComa flotante con o sin exponente según el caso. No se visualizan ni lo ceros finales ni el punto decimal cuando no es necesario.\r\n\r\ni\r\n\r\nEntero con signo\r\n\r\no\r\n\r\nEntero octal, sin el cero inicial\r\n\r\ns\r\n\r\nCadena de caracteres\r\n\r\nu\r\n\r\nEntero decimal sin signo\r\n\r\nx\r\n\r\nEntero hexadecimal sin el prefijo 0x\r\n\r\n\r\n\r\nTabla 1.9: Caracteres de conversión de los datos de salida de uso común\r\n\r\nEjemplo 1.20:\r\n#include <stdio.h>\r\n\r\nmain()\r\n\r\n{\r\n\r\nchar concepto[20]=\"cremallera\";\r\n\r\nint no_partida=12345;\r\n\r\nfloat coste=0.05;\r\n\r\nprintf(\"%s %d %f\", concepto, no_partida, coste);\r\n\r\n}\r\n\r\nDentro de la función printf de este programa, la cadena de control es \"%s %d %f\". Contiene tres grupos de caracteres. El primer grupo, %s, indica que el primer argumento (concepto) representa a una cadena de caracteres. El segundo grupo, %d, indica que el segundo argumento (no_partida) representa un valor entero decimal, y el tercer grupo, %f, indica que el tercer argumento (coste) representa un valor en coma flotante.\r\n\r\nEl resultado de la ejecución de estas instrucciones del programa es visualizar en el monitor la siguiente salida:\r\n\r\ncremallera 12345 0.050000\r\n\r\nLas funciones gets y puts\r\nLa función de biblioteca gets permite leer una cadena de caracteres desde el dispositivo de entrada estándar. Su sintaxis es\r\n\r\ngets(variable);\r\n\r\ndonde variable debe ser una cadena de caracteres\r\n\r\nLa función de biblioteca puts permite visualizar una cadena de caracteres en el dispositivo de salida estándar. Su sintaxis es\r\n\r\nputs(variable);\r\n\r\ndonde variable debe ser una cadena de caracteres\r\n\r\nEjemplo 1.21:\r\n/*El siguiente código permite leer y escribir una línea de texto*/\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n\r\n{\r\n\r\nchar linea[80];\r\n\r\ngets(linea);\r\n\r\nputs(linea);\r\n\r\n}', NULL),
(92, 8, '8.06', 'Funciones de manipulación de cadenas de la biblioteca de manipulación de cadenas\r\n', 'Funciones Asociadas al Manejo de cadenas de caracteres\r\nAunque C no incorpora en su definición operadores para el manejo de cadenas de caracteres, todo compilador de C proporciona una librera estándar (string.h) con funciones para facilitar su utilización. Destacar algunas de ellas:\r\n\r\n Nombre	 Descripcion	 sintaxis\r\n strcpy:	 La función strcpy se encuentra en la biblioteca <string.h> y se utiliza para copiar una cadena de caracteres (fuente) en el lugar que ocupaba otra (destino). Esta copia es destructiva, o sea, que todos los caracteres que estaban en la cadena destino desaparecen, aunque la cadena destino fuera más larga que la cadena fuente .	 strcpy(<variable_destino>,<variable_fuente>);\r\n strcat:	 En el programa anterior vimos que la función strcpy es desctructiva, pero hay otra función en la librería <string.h> que copia una cadena (fuente) en otra (destino) sin destruir ésta, es decir, que copia una cadena detrás de la otra esta función es conocida como strcat. 	 strcat(<variable_destino>,<variable_fuente>);\r\n strlen: 	 esta función devuelve el total (entero) de caracteres que conforman una cadena (excluyendo el caracter nulo \\0).	  <variable>=strlen(<cadena>);\r\n strcmp:	 strcmp (abreviatura de ((string comparison))). La función strcmp recibe dos cadenas, a y b, devuelve un entero. El entero que resulta de efectuar la llamada strcmp(a, b) codifica el resultado de la comparación:es menor que cero si la cadena a es menor que b,es 0 si la cadena a es igual que b, yes mayor que cero si la cadena a es mayor que b.\r\n int strcmp(const char *s1,const char *s2);\r\n isalum:	 devuelve cierto (un entero cualquiera distinto de cero) si caracter es una letra o dígito, y falso (el valor entero 0) en caso contrario.	 int isalum (int c);\r\n isalpha:	 devuelve cierto si caracter es una letra, y falso en caso contrario.	 int isalpha (int c);\r\n isblank	  devuelve cierto si caracter es un espacio en blanco o un tabulador.	 isblank(<valor>)\r\n isdigit	 devuelve cierto si caracter es un digito, y falso en caso contrario.	 int isdigit(int c)\r\n isspace	 devuelve cierto si caracter es un espacio en blanco, un salto de línea, un retorno de carro, un tabulador, etc., y falso en caso contrario.	 int isspace(int c);\r\n toupper	 devuelve la mayúscula asociada a caracter, si la tiene; si no, devuelve el mismo caracter.	 int toupper(int c);\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\nchar nom1[10]=\"cristian\";\r\nchar nom2[10]=\"manuel\";\r\nint TAM;\r\nint main()\r\n{\r\n    strcpy(nom2,nom1);\r\n    printf(\"%s\\n\",nom2);\r\n    getch();\r\n    printf(\"%s\\n\",nom1);\r\n    getch();\r\n\r\n    strcpy(nom1,\"Hola\");\r\n    printf(\"%s\\n\",nom1);\r\n    getch();\r\n\r\n    strcat(nom2,nom1);\r\n    printf(\"%s\\n\",nom2);\r\n    getch();\r\n\r\n    TAM=strlen(nom2);\r\n    printf(\"%i\",TAM);\r\n    getch();\r\n\r\n\r\n    return 0;\r\n}', NULL),
(93, 8, '8.07', 'Funciones de comparación de la biblioteca de manipulación de cadenas', 'Operadores de comparación en C\r\nEstos operadores comparan dos variables, dando como resultado valores booleanos, true (verdadero) o false (falso), dependiendo de si las variables cumplen o no la operación indicada.\r\n\r\nSon “==” (dos signos = seguidos), “!=”, “<“, “>”, “<=” y “>=”, que comprueban relaciones de igualdad, desigualdad y comparaciones entre dos valores aritméticos. Sintaxis:\r\n\r\n<variable> == <variable>\r\n\r\n<variable> != <variable>\r\n\r\n<variable> > <variable>\r\n\r\n<variable> < <variable>\r\n\r\n<variable> <= <variable>\r\n\r\n<variable> >= <variable>\r\n\r\nSi el resultado de la comparación resulta ser verdadero, se retorna true, en caso contrario false. El significado de cada operador es evidente:\r\n\r\n== igualdad\r\n\r\n!= desigualdad\r\n\r\n> mayor que\r\n\r\n< menor que\r\n\r\n>= mayor o igual que\r\n\r\n<= menor o igual que', NULL),
(94, 8, '8.08', 'Funciones de búsqueda de la biblioteca de manipulación de cadenas\r\n', 'Constantes y tipos\r\nNombre	Descripción\r\nNULL	macro que representa la constante puntero nulo; representa un valor de puntero que no apunta a ninguna dirección válida de objeto alguno en memoria\r\nsize_t	tipo entero sin signo (positivo); es el tipo devuelto por el operador sizeof\r\nFunciones\r\nNombres	Descripción\r\nmemcpy	copia n bytes entre dos áreas de memoria que no deben solaparse\r\nmemmove	copia n bytes entre dos áreas de memoria; al contrario que memcpy las áreas pueden solaparse\r\nmemchr	busca un valor a partir de una dirección de memoria dada y devuelve un puntero a la primera ocurrencia del valor buscado o NULL si no se encuentra\r\nmemcmp	compara los n primeros caracteres de dos áreas de memoria\r\nmemset	sobre escribe un área de memoria con un patrón de bytes dado\r\nstrcat	añade una cadena al final de otra\r\nstrncat	añade los n primeros caracteres de una cadena al final de otra\r\nstrchr	localiza un carácter en una cadena, buscando desde el principio\r\nstrrchr	localiza un carácter en una cadena, buscando desde el final\r\nstrcmp	compara dos cadenas alfabéticamente (\'a\'!=\'A\')\r\nstrncmp	compara los n primeros caracteres de dos cadenas numéricamente (\'a\'!=\'A\')\r\nstrcoll	compara dos cadenas según la colación actual (\'a\'==\'A\')\r\nstrcpy	copia una cadena en otra\r\nstrncpy	copia los n primeros caracteres de una cadena en otra\r\nstrerror	devuelve la cadena con el mensaje de error correspondiente al número de error dado\r\nstrlen	devuelve la longitud de una cadena\r\nstrspn	devuelve la posición del primer carácter de una cadena que no coincide con ninguno de los caracteres de otra cadena dada\r\nstrcspn	devuelve la posición del primer carácter que coincide con alguno de los caracteres de otra cadena dada\r\nstrpbrk	encuentra la primera ocurrencia de alguno de los caracteres de una cadena dada en otra\r\nstrstr	busca una cadena dentro de otra\r\nstrtok	parte una cadena en una secuencia de tokens\r\nstrxfrm	transforma una cadena en su forma de colación (??)\r\nstrrev	invierte una cadena\r\nExtensiones para C ISO\r\nNombre	Descripción	Especificación\r\nstrdup	hace un duplicado de la cadena dada reservando dinámicamente la memoria necesaria	POSIX; originalmente una extensión BSD\r\nstrcpy s	variante de strcpy que verifica los límites limitados	ISO/IEC WDTR 24731\r\nmempcpy	variante de memcpy que devuelve un puntero al byte siguiente al último byte escrito	GNU\r\nmemccpy	variante de memcpy que para al encontrar un byte determinado	UNIX 98?\r\nstrerror r	análogo a strerror_r (thread-safe)	GNU, POSIX\r\nstrlcpy	variante de strcpy que verifica los límites	originalmente OpenBSD, actualmente también FreeBSD, Solaris, OS X\r\nstrtok r	versión thread-safe de strtok	POSIX\r\nstrsignal	análogamente a strerror, devuelve la cadena por minorías del arreglo cadena en la representación de la señal sig (no thread safe)	BSDs, Solaris, Linux', NULL),
(95, 8, '8.09', 'Funciones de memoria de la biblioteca de manipulación de cadenas\r\n', 'En C, la función malloc, perteneciente a la cabecera stdlib.h, se utiliza para asignar un bloque de memoria en el montón. El programa accede a este bloque de memoria a través de un puntero que malloc regresa. Cuando ya no se necesita la memoria, se pasa el puntero a la función free, la cual libera la memoria de modo que se puede utilizar para otros fines.\r\n\r\nAlgunas plataformas ofrecen llamadas de biblioteca que permiten en tiempo de ejecución la asignación dinámica de la pila C en lugar de la pila (por ejemplo Unix alloca(), Microsoft Windows de CRTL malloca() ). Esta memoria se libera automáticamente cuando la función de llamada termina. La necesidad de este se ve reducida por los cambios en el estándar C99, que añade soporte para arrays de longitud variable de ámbito de bloque que tienen tamaños que determine en tiempo de ejecución.\r\n\r\nResumen de las funciones\r\nLas funciones de asignación de memoria dinámica en C se definen en la cabecera stdlib.h. (cstdlib en C++)\r\n\r\nFunción	Descripción\r\nmalloc	asigna el número especificado de bytes\r\nrealloc	aumenta o disminuye el tamaño del bloque de memoria especificada. Reasigna si es necesario\r\ncalloc	asigna el número especificado de bytes y los inicializa a cero(0).\r\nfree	libera el bloque de memoria especificada de nuevo al sistema\r\nLas diferencias entre malloc() y calloc()\r\nHay dos diferencias entre estas funciones. En primer lugar, malloc() toma un único argumento (la cantidad de memoria para asignar en bytes), mientras calloc() necesita dos argumentos (el número de variables para asignar en la memoria y el tamaño en bytes de una sola variable).\r\n\r\nEn segundo lugar, malloc() no inicializa la memoria asignada, mientras calloc() inicializa todos los bytes del bloque de memoria asignada a cero.\r\n\r\nEjemplo de uso\r\nCreación de un vector (array) de 10 enteros con el alcance automático es muy sencillo:\r\n\r\nint array[10];\r\nSin embargo, el tamaño de la matriz se fija en tiempo de compilación. Si se quiere asignar una gama similar de forma dinámica, se puede utilizar el siguiente código:\r\n\r\n/* Asignar espacio para una matriz con diez elementos de tipo int. Algunos programadores incluyen el conversor explícito  \"(int *)\" \r\n\r\nantes del malloc aunque no sea necesario. */\r\nint * array = malloc(10 * sizeof(int));\r\n\r\n/* Comprueba que la memoria se asignó correctamente, en caso contrario se gestiona el error. */\r\nif (NULL == array) {\r\n    /* gestión del error en la asignación… */\r\n}\r\n\r\n/* Si llegamos a este punto significa que la memoria ha sido asignada correctamente… */\r\n\r\n/* Una vez hayamos finalizado el uso de la memoria debemos liberar la misma para usos futuros. */\r\n\r\nfree(array);\r\n\r\n/* Nos aseguramos que el puntero ya no se usa asignándolo a NULL (u otra región de memoria asignada). */\r\narray = NULL;\r\nmalloc() devuelve un puntero nulo (NULL) para indicar que no hay memoria disponible, o que se ha producido algún otro error que impidió la asignación de la memoria.\r\n\r\nTipo de seguridad\r\nmalloc devuelve un puntero nulo (void *), lo que indica que es un puntero a una región de tipo de datos desconocido. Se requiere el uso del casting en C + + debido al fuerte sistema de tipos, mientras que éste no es el caso de C. La falta de un tipo de puntero específico de retorno de malloc es un comportamiento de tipo-inseguro de acuerdo a algunos programadores: la asignación de memoria de malloc se basa en el recuento de bytes pero no en el tipo de dato. Esto es distinto a la asignación new de C++ que devuelve un puntero basado en el tipo de operando.\r\n\r\nUno puede usar un \"cast\" (ver conversión de tipos) de este puntero a un tipo específico:\r\n\r\nint * ptr;\r\nptr = malloc (10 * sizeof (* ptr)); /* sin una conversión */\r\nptr = (int *) malloc (10 * sizeof (* ptr)); /* con un cast */\r\nptr = reinterpret_cast <int *> (malloc (10 * sizeof (* ptr))); /* con un cast, para C++ */', NULL);
INSERT INTO `indices` (`id_indices`, `id_capitulo`, `numero_ind`, `nombre_ind`, `descripcion_ind`, `indice_id`) VALUES
(96, 8, '8.10', 'Otras funciones de la biblioteca de manipulación de cadenas\r\n', 'Funciones que facilitan el trabajo con cadenas de caracteres (string.h)\r\n\r\n\r\n \r\nHemos visto en el concepto anterior que en el lenguaje C para trabajar con cadenas de caracteres debemos definir un vector de caracteres de un tamaño definido, por ejemplo:\r\n\r\nchar palabra[31];\r\nEn la línea anterior estamos definiendo un vector de caracteres que nos permite almacenar hasta 30 caracteres (recordar que una posición del vector se requiere para el terminador de cadena \'\\0\')\r\n\r\nDesarrollamos anteriormente un algoritmo para contar la cantidad de letras que almacena una cadena de caracteres, básicamente recorrimos mediante un while y contamos cada caracter hasta que encontramos el terminador de cadena \'\\0\'.\r\n\r\nHay muchos algoritmos de uso común para trabajar con cadenas de caracteres, el lenguaje C viene con un conjunto de funciones que nos permiten administrar las cadenas de caracteres.\r\n\r\nPara facilitar el trabajo con las cadenas de caracteres debemos incluir el archivo string.h y a partir de esto usar sus funcionalidades:\r\n\r\n#include<string.h>\r\nfunción: strlen\r\nProblema 1:\r\nIngresar por teclado una palabra. Mostrar luego por pantalla la cantidad de letras que tiene.\r\n\r\nPrograma: programa77.c\r\nVer video\r\n#include<stdio.h>\r\n#include<conio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n    char palabra[31];\r\n    printf(\"Ingrese una palabra:\");\r\n    gets(palabra);\r\n    int cant=strlen(palabra);\r\n    printf(\"La palabra %s tiene %i letras\",palabra,cant);\r\n    getch();\r\n    return 0;\r\n}\r\nLo primero que hacemos ahora es incluir los archivos stdio.h, conio.h y string.h:\r\n\r\n\r\n \r\n#include<stdio.h>\r\n#include<conio.h>\r\n#include<string.h>\r\nLa función strlen se le pasa como parámetro una variable de tipo cadena de caracteres (vector de tipo char) y nos retorna un entero que representa la cantidad de caracteres almacenados en dicha cadena:\r\n\r\n    int cant=strlen(palabra);\r\nEl valor devuelto por la función strlen se carga en la variable cant que procedemos a mostrarla seguidamente:\r\n\r\n    printf(\"La palabra %s tiene %i letras\",palabra,cant);\r\nTener en cuenta que la llamada a la función strlen nos evita implementar el while con el contador de caracteres:\r\n\r\n#include<stdio.h>\r\n#include<conio.h>\r\n\r\nint main()\r\n{\r\n    char palabra[31];\r\n    printf(\"Ingrese una palabra:\");\r\n    gets(palabra);\r\n    int cant=0;\r\n    while (palabra[cant]!=\'\\0\')\r\n    {\r\n        cant++;\r\n    }\r\n    printf(\"La palabra %s tiene %i letras\",palabra,cant);\r\n    getch();\r\n    return 0;\r\n}\r\n\r\n \r\nImaginemos si tenemos que calcular la cantidad de caracteres de muchas cadenas durante un programa.\r\n\r\nfunción: strcmp\r\nHasta ahora no desarrollamos programas que comparen el contenido de dos cadenas de caracteres. Lo primero que hay que decir que no están definidos los operadores relacionales ==, >, < etc.\r\n\r\nEs incorrecto tratar de comparar si dos cadenas son iguales.\r\n\r\nif (nombre1==nombre2)\r\n{\r\n    printf(\"Son iguales los nombres\")\r\n}\r\nPodemos implementar nosotros un análisis dentro de un while y comparar caracter a caracter, pero este algoritmo no es tan fácil y cómodo de implementar cada vez que tenemos que comparar dos cadenas.\r\n\r\nEntonces el lenguaje C tiene otra función llamada strcmp que le pasamos dos cadenas a comparar y nos retorna un entero:\r\n\r\nint strcmp(cadena1,cadena2)\r\nRetorna un cero si las dos cadenas son exactamente iguales.\r\n\r\nRetorna un valor mayor a cero si la cadena1 es mayor alfabéticamente que la segunda.\r\n\r\nRetorna un valor menor a cero si la cadena2 es mayor alfabéticamente que la primera.\r\n\r\nProblema 2:\r\nIngresar dos nombres por teclado. Mostrar un mensaje si son iguales y sino mostrar el que es mayor alfabéticamente.\r\n\r\nPrograma: programa78.c\r\nVer video\r\n#include<stdio.h>\r\n#include<conio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n    char nombre1[31];\r\n    char nombre2[31];\r\n    printf(\"Ingrese primer nombre:\");\r\n    gets(nombre1);\r\n    printf(\"Ingrese segundo nombre:\");\r\n    gets(nombre2);\r\n    if (strcmp(nombre1,nombre2)==0)\r\n    {\r\n        printf(\"Los dos nombres son iguales\");\r\n    }\r\n    else\r\n    {\r\n        if (strcmp(nombre1,nombre2)>0)\r\n        {\r\n            printf(\"%s es mayor alfabeticamente\",nombre1);\r\n        }\r\n        else\r\n        {\r\n            printf(\"%s es mayor alfabeticamente\",nombre2);\r\n        }\r\n    }\r\n    getch();\r\n    return 0;\r\n}\r\nPrimero definimos dos vectores de caracteres y los cargamos por teclado:\r\n\r\n\r\n \r\n    char nombre1[31];\r\n    char nombre2[31];\r\n    printf(\"Ingrese primer nombre:\");\r\n    gets(nombre1);\r\n    printf(\"Ingrese segundo nombre:\");\r\n    gets(nombre2);\r\nPara controlar si los dos nombres son iguales verificamos si la función strcmp retorna un cero:\r\n\r\n    if (strcmp(nombre1,nombre2)==0)\r\n    {\r\n        printf(\"Los dos nombres son iguales\");\r\n    }\r\nEn el caso que retorne un valor mayor a cero significa que el primer nombre es mayor alfabéticamente:\r\n\r\n        if (strcmp(nombre1,nombre2)>0)\r\n        {\r\n            printf(\"%s es mayor alfabeticamente\",nombre1);\r\n        }\r\nFuncionamiento interno de strcmp.\r\nDefinimos dos cadenas de 7 elementos y las inicializamos:\r\n\r\n	char cadena1[7]=\"Bien\";\r\n	char cadena2[7]=\"Bueno\";\r\nEl contenido de las componente de cada una de las cadenas es el siguiente:\r\n\r\ncomponente	[0]	[1]	[2]	[3]	[4]	[5]	[6]\r\ncadena1	        ‘B’	‘i’	‘e’	‘n’	‘\\0’\r\ncadena2	        ‘B’	‘u’	‘e’	‘n’	‘o’	‘\\0’\r\nEl contenido de las componente de cada una de las cadenas (en valores ASCII) es el siguiente:\r\n\r\ncomponente	[0]	[1]	[2]	[3]	[4]	[5]	[6]\r\ncadena1	        66	105	101	110	0\r\ncadena2	        66	117	101	110	111	0\r\nSeguidamente llamamos a la función strcmp, la cual devuelve un valor entero que le asignamos a una variable resultado:\r\n\r\n	int resultado=strcmp(cadena1,cadena2);\r\nInternamente la función hace lo siguiente:\r\nResta al valor ASCII de la primer componente de cadena1 (66) el valor de la primer componente de cadena2 (66). Como el resultado es cero (0), continúa con la siguiente componente. Resta al valor de la segunda componente de cadena1 (105) el valor de la segunda componente de cadena2 (117), como el resultado es diferente de cero no sigue comparando y devuelve ese valor (-12):\r\n\r\ncomponente	[0]	[1]	[2]	[3]	[4]	[5]\r\ncadena1	        66	105	101	110	0\r\ncadena2	        66	117	101	110	111	0\r\nResultado	 0	-12\r\n\r\n \r\nEsa es la explicación de porque strcmp retorna 0 si son iguales las dos cadenas y un valor mayor a 0 si la primer cadena es mayor a la segunda y viceversa.\r\n\r\nfunción: strcpy\r\nHemos visto que si necesitamos comparar dos string (string es sinónimo de cadenas de caracteres o vectores) no tenemos disponibles los operadores relacionales ==, > etc.\r\nSi necesitamos copiar un string en otro tampoco funciona el operador de asignación =, para resolver este problema el lenguaje C nos proporciona la función srtcpy.\r\n\r\nLa función strcpy tiene dos parámetros de tipo string, al primer parámetro se le copia el string del segundo parámetro:\r\n\r\nstrcpy(cadena1,cadena2)\r\nEs decir que en cadena1 se copia el contenido de cadena2, si ya tenía información previa cadena1 se le borra el contenido anterior.\r\n\r\nProblema 3:\r\nCargar por teclado dos nombres de personas que tengan distinta cantidad de caracteres. Almacenar en un tercer vector de caracteres el nombre que tenga más caracteres. Luego imprimir dicho vector.\r\n\r\nPrograma: programa79.c\r\nVer video\r\n#include<stdio.h>\r\n#include<conio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n    char nombre1[31];\r\n    char nombre2[31];\r\n    char nombreLargo[31];\r\n    printf(\"Ingrese primer nombre:\");\r\n    gets(nombre1);\r\n    printf(\"Ingrese segundo nombre:\");\r\n    gets(nombre2);\r\n    if (strlen(nombre1)>strlen(nombre2))\r\n    {\r\n        strcpy(nombreLargo,nombre1);\r\n    }\r\n    else\r\n    {\r\n        strcpy(nombreLargo,nombre2);\r\n    }\r\n    printf(\"El nombre %s tiene mas caracteres\",nombreLargo);\r\n    getch();\r\n    return 0;\r\n}\r\nDefinimos tres string, dos los cargamos por teclado y el tercero lo inicializamos mediante la función strcpy:\r\n\r\n\r\n \r\n    char nombre1[31];\r\n    char nombre2[31];\r\n    char nombreLargo[31];\r\nMediante la función strlen verificamos cual de los dos string tiene más caracteres y copiamos en la variable de tipo string nombreLargo el contenido de nombre1 o nombre2 según corresponda:\r\n\r\n    if (strlen(nombre1)>strlen(nombre2))\r\n    {\r\n        strcpy(nombreLargo,nombre1);\r\n    }\r\n    else\r\n    {\r\n        strcpy(nombreLargo,nombre2);\r\n    }\r\nTener en cuenta que no existe la asignación:\r\n\r\nnombreLargo=nombre1;\r\nSi en un problema necesitamos dejar un string vacío podemos utilizar la función strcpy pasando un string sin caracteres (no debe haber ni un espacio en blanco):\r\n\r\nstrcpy(cadena,\"\");\r\nOtra forma de hacer lo mismo sin utilizar la función strpy es asignar el terminador de cadena a la primer posición del string:\r\n\r\ncadena[0]=\'\\0\';\r\nfunción: strcat\r\nSi necesitamos agregar a un string otro string podemos utilizar la función strcat.\r\n\r\nLa función strcat tiene dos parámetros de tipo string, al primer parámetro se le añade o agrega al final el string del segundo parámetro, es obligatorio que el primer parámetro esté inicializado:\r\n\r\nstrcat(cadena1,cadena2)\r\nProblema 4:\r\nCargar por teclado en dos variables de tipo string el nombre y el apellido de una persona. Definir un tercer string y guardar la concatenación del nombre y apellido.\r\nPrograma: programa80.c\r\nVer video\r\n#include<stdio.h>\r\n#include<conio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n    char nombre[31];\r\n    char apellido[31];\r\n    char nomape[62];\r\n    printf(\"Ingrese el nombre:\");\r\n    gets(nombre);\r\n    printf(\"Ingrese el apellido:\");\r\n    gets(apellido);\r\n    strcpy(nomape,nombre);\r\n    strcat(nomape,\" \");\r\n    strcat(nomape,apellido);\r\n    printf(\"%s\",nomape);\r\n    getch();\r\n    return 0;\r\n}\r\nDefinimos dos variables donde almacenar el nombre y apellido:\r\n\r\n    char nombre[31];\r\n    char apellido[31];\r\nComo sabemos podemos guardar como máximo 30 caracteres en el nombre y 30 caracteres en el apellido, luego el string que almacenará los dos datos juntos más un espacio en blanco entre el nombre y apellido debe reservar espacio para 62 caracteres:\r\n\r\n    char nomape[62];\r\nLuego de cargar los dos string primero copiamos en la variable nomape el nombre de la persona empleando la función strcpy:\r\n\r\n    strcpy(nomape,nombre);\r\nSeguidamente le agregamos al string nomape un string con un único caracter:\r\n\r\n    strcat(nomape,\" \");\r\nY por último le agregamos el string con el apellido:\r\n\r\n    strcat(nomape,apellido);', NULL),
(97, 1, '1.10', 'hdhjfjfuhvuj', 'ihbhbihibi', 1),
(98, 1, '1.1.1', 'ewfewef', 'ewfwefweff', 1);

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `usuarios`
--

CREATE TABLE `usuarios` (
  `id_usuario` int(11) NOT NULL,
  `nombre` varchar(25) DEFAULT NULL,
  `apellido` varchar(25) DEFAULT NULL,
  `correo` varchar(60) DEFAULT NULL,
  `contrasena` varchar(60) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Volcado de datos para la tabla `usuarios`
--

INSERT INTO `usuarios` (`id_usuario`, `nombre`, `apellido`, `correo`, `contrasena`) VALUES
(1, 'Esteban ', 'Ortiz', 'ecortizzamb@gmail.com', 'estebancamilo19');

--
-- Índices para tablas volcadas
--

--
-- Indices de la tabla `capitulos`
--
ALTER TABLE `capitulos`
  ADD PRIMARY KEY (`id_capitulo`);

--
-- Indices de la tabla `indices`
--
ALTER TABLE `indices`
  ADD PRIMARY KEY (`id_indices`),
  ADD KEY `id_capitulo` (`id_capitulo`),
  ADD KEY `indice_id` (`indice_id`);

--
-- Indices de la tabla `usuarios`
--
ALTER TABLE `usuarios`
  ADD PRIMARY KEY (`id_usuario`);

--
-- AUTO_INCREMENT de las tablas volcadas
--

--
-- AUTO_INCREMENT de la tabla `capitulos`
--
ALTER TABLE `capitulos`
  MODIFY `id_capitulo` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=10;

--
-- AUTO_INCREMENT de la tabla `indices`
--
ALTER TABLE `indices`
  MODIFY `id_indices` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=99;

--
-- AUTO_INCREMENT de la tabla `usuarios`
--
ALTER TABLE `usuarios`
  MODIFY `id_usuario` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- Restricciones para tablas volcadas
--

--
-- Filtros para la tabla `indices`
--
ALTER TABLE `indices`
  ADD CONSTRAINT `indices_ibfk_1` FOREIGN KEY (`id_capitulo`) REFERENCES `capitulos` (`id_capitulo`),
  ADD CONSTRAINT `indices_ibfk_2` FOREIGN KEY (`indice_id`) REFERENCES `indices` (`id_indices`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
